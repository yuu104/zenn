---
title: "E2Eテスト"
---

## E2E テストとは？

ユーザーの実際の使用シナリオに基づいて、アプリケーションの開始から終了までの全プロセスをテストする手法です。

:::details 全プロセスをテストする？？

Web アプリケーションは、以下にある様々なモジュールを組み合わせて実装されています。

1. ライブラリが提供する関数
2. ロジックを担う関数
3. UI を表現する関数
4. Web API クライアント
5. API サーバー
6. DB サーバー

E2E 自動テストは、1〜6 までを「ヘッドレスブラウザ」+「UI オートメーション」の組み合わせを中心に構成されたテスティングフレームワークを用いて、検証します。

:::

## 特徴

1. **使用するインターフェースはユーザーインターフェース**
   - システムとしてユーザーに提供するものをテストする
2. **テストケースはユーザーストーリー**
   - ユーザーがその機能を用いて達成したいことをテストする
   - 技術的制約によってユーザーストーリー以外のものをテストすることもある
3. **テスト対象は完全に統合されたシステム全体**
   - マイクロサービスアーキテクチャの場合、全てのサービスが揃った完全な状態での動作を確認する
4. **想定されるバグは、「ユーザーストーリーそのものの失敗」**
   - 「ログイン出来ない」
   - 「商品がカートに入らない」

## メリット

ここでは、E2E テストを行うことによる利点を説明します。

### ① ユーザーストーリーそのものをテストできる

E2E テストの大きな特徴は、ユーザーストーリーをそのままテストできる点です。
これは他のテストレベルではほぼ不可能な、E2E テスト独自の強みです。

ユーザーインターフェースを通じて実際のユーザー操作を再現することで、ソフトウェアが本当にユーザーの期待通りに動作するかを確認できます。
これにより、「**ユーザーストーリーの失敗**」という最も深刻なバグを発見することができます。

この特性は、開発者やテスターにとって重要な責任も伴います。E2E テストを適切に実施することで、「こんな簡単なことも見落としていたのか」という批判を避け、ユーザーの満足度を高めることができるのです。

### ② 幅広い用途に利用できる

単体テストや結合テストでは難しい、以下の検証を行うことができます。

1. **互換性の確認**
   E2E テストを使えば、様々なブラウザ、OS、デバイスでソフトウェアが正しく動作するかを効率的に確認できます。
   これを手動テストでやろうとすると、大きなコストが必要になります...
2. **「生きたドキュメント」として**
   E2E テストは、ソフトウェアの使い方や機能を示す「生きたドキュメント」として活用できます。
   テストコードを読むことで、システムの動作を理解できるのです。
   さらに、ソフトウェアが変更されると自動的にテストが失敗するので、ドキュメントの更新忘れを防げます。
3. **仕様の可視化**
   詳細な仕様書がない古いシステムや、急速に開発が進んでいるプロジェクトでは、E2E テストを使って現在の仕様を可視化できます。
   UI の操作を通じてシステムの振る舞いを記録することで、「動くドキュメント」を作成できるのです。
4. **システムの監視ツールとして**
   実際のユーザー操作を模したテストを定期的に実行することで、システムの健全性を常にチェックできます。
   新しい機能をリリースした直後など、システムの基本的な機能が正常に動作しているかを素早く確認したい場合にも有効です。

## デメリット

E2E テストはいいことばかりではありません。
ネガティブな面やリスクについても説明しておきます。

### ① 自動化の難度と複雑性が高い

E2E テストの大きなデメリットの一つは、自動化そのものに必要な作業が複雑で、思わぬ落とし穴にはまりやすいことです。

#### E2E テスト自動化に必要な要素

そもそも、E2E テストを自動実行するには、最低でも以下の要素が必要になります。

1. **テスト対象のシステム**
   - システム全体が統合された状態
   - 実ユーザーが利用するのと同等の環境が必要
2. **クライアント**
   - ブラウザやモバイルデバイスなど
   - 場合によってはリアルデバイスではなく、エミュレーターなどで代替することも
3. **オートメーションツール**
   - ユーザーインターフェースを自動操作するためのツール
   - ブラウザなどのクライアントソフトウェア自身が提供している場合や、サードパーティのツールを利用する場合がある

テストのために多くの要素が必要となり、単体テストや結合テストと比べてもかなり複雑です...

#### 自動化する上での課題

複数の要素を連携してテストするため、様々なことを考慮する必要があります。

1. **ツールのバグによる影響**
   - クライアントやオートメーションツールのバグに遭遇する可能性がある
   - 例：Google Chrome を自動操作するための ChromeDriver
2. **多様な環境への対応**
   - 新しいブラウザや多種多様なブラウザをテストしたいという要求がある
   - これらの環境自体が抱える問題により、自動テストがうまく動かないケースが発生する
3. **エミュレーターやシミュレーターの利用**
   - クライアントやモバイルデバイスのエミュレーター/シミュレーターを利用する場合、これらがトラブルを引き起こす可能性がある
4. **システム外部への依存**
   - E2E テストはシステムを外から利用してテストする
   - 他のテストレベルとは異なり、システムの外に大きく依存するテスト
   - 実装における考慮事項が非常に多くなる
5. **セキュリティ設定などの考慮**
   - 開発中のシステム特有のセキュリティ設定など、特別な考慮事項が存在する可能性がある

E2E テストは他のテストレベルとは異なり、**システムの外に大きく依存する**テストです。
そのため、実装における考慮事項は多くなります。

![](https://storage.googleapis.com/zenn-user-upload/56a5276b8734-20240924.png =350x)

### ② テスタビリティへの配慮が難しい

E2E テストは、システム全体の「振る舞い」を検証する強力なツールですが、同時にテスタビリティに関して特有の課題を抱えています。

#### 内部状態の取得の難しさ

E2E テストは主にシステム全体の外部から観察可能な振る舞いに焦点を当てますが、特定の条件下での動作を検証するために、やむを得ずシステム内部の状態を取得する必要が生じる場合があります。
しかし、E2E テストにおいてこのような内部状態の取得を実装することは以下の懸念点があります。

- システムの内部構造に深く依存するテストコードを書く必要があり、保守性が低下する
- テスト用の特別なインターフェースや機能を追加する必要があり、本番環境との乖離が生じる可能性がある
- 内部状態の取得自体がシステムの挙動に影響を与え、テスト結果の信頼性を損なう可能性がある

この問題により、複雑な条件や状態遷移を伴うテストシナリオの実装は難しいのです...

#### モックとスタブの利用制限

単体テストや統合テストでは、モックやスタブを使用してテスト対象を分離し、特定の条件下での動作を検証することが一般的です。
しかし、E2E テストではこれらの技法の使用には以下の懸念点があります。

- 実際の環境での動作を検証するという E2E テストの本質的な目的と相反する
- システム全体の統合状態を正確に反映できなくなる可能性がある

外部のサードパーティ API を利用する場合を例にすると以下のようなトレードオフを考慮する必要があります。

1. **実際の API を使用する場合**
   - テストの信頼性が向上する
   - しかし、API の動作や可用性に依存してテストが不安定になる可能性がある
   - コストやレート制限の問題が発生する可能性がある
2. **API をモック化する場合**
   - テストの安定性と再現性が向上する
   - しかし、「完全に統合された状態のシステムのテスト」という E2E テストの本来の価値が損なわれる
   - 実際の環境で発生する可能性のある問題を見逃す危険性がある

### ③ 高コスト

E2E テストの実施にはコストがかかります。

1. **時間的なコスト**
   - 本物のブラウザやモバイルデバイスなどを利用するため、起動やページロードも含め、実行時間が長くなります
   - ログインが必要なシステムでは、テストケースの度にログイン処理が必要になり、実行時間が長くなる可能性があります
2. **金銭的なコスト**
   - 環境やデバイスの数に比例して金銭的コストが増加します
   - 完全に統合された状態でシステムを起動する必要があるため、場合によっては本番環境と同等の環境を準備する必要があります

## E2E テストの導入前に考えること

E2E テストによる恩恵は大きいですが、一方で導入ハードルはとても高いです。
では、どのようなことを考慮して E2E テストを開始していけばよいのでしょうか？

### ① 現状のテスト状況を把握する

テストには「単体テスト」「結合テスト」「E2E テスト」「手動テスト」等、複数のレベルが存在します。まずは、これらテストレベルのコスト配分が現状どのようになっているのかを把握する必要があります。

例えば、よく知られているベストプラクティスとして**テストピラミッド**があります。
これは、下層のテストが多くなるモデルで、安定した費用対効果の高いテスト戦略と言われています。

一方、真逆のバッドプラクティスとして**アイスクリームコーン**というものもよく知られています。
これは、極めて少ない量の自動テストと、大量の手動テストに依存した状態です。

![](https://storage.googleapis.com/zenn-user-upload/34579ee95405-20240926.png =600x)
_左: テストピラミッド、右: アイスクリームコーン
引用: https://codezine.jp/article/detail/19909_

\
他にも形態はありますが、大事なのは、**現状を把握する**ということです。

現状を知らなければ、何から始めれば良いのか？も分かりません。
闇雲に進めて...結局問題が解決しない...という事態に陥ってしまいます。

### ② 短期的な戦略と長期的な戦略を分けて考える

現状を把握した結果、テスト状況がアイスクリームコーンであったとしましょう。（テストに悩む多くの現場は、このケースが多いらしいです...）
開発プロセスが大量の手動テストに依存してしまっているため、何とか改善したいです...
できればテストピラミッドの状態にしたいです！！！

![](https://storage.googleapis.com/zenn-user-upload/09f16ae92610-20240925.png)
_現状を変えたいぃ....!
引用: https://codezine.jp/article/detail/19909_

\
しかし、いきなり変えるのは流石に難しいです...
ではどうするか？？

短期的な戦略と長期的な戦略を分け、以下のように段階的に進めていくのが得策です。
![](https://storage.googleapis.com/zenn-user-upload/b1ed508b2b46-20240925.png)
_少しずつ着実に改善する
引用: https://codezine.jp/article/detail/19909_

#### 短期的な戦略

まずは「手動テストが多い」という状況から脱却することを目指します。
そのための手段として、E2E テストを導入して自動化します。

手動テストは通常、実際のユーザーの行動を模倣して検証を行います。
E2E テストも同様に、ユーザーの視点からシステム全体の動作を確認するため、手動テストのシナリオを変換しやすいです。

![](https://storage.googleapis.com/zenn-user-upload/a1b05c441c41-20240927.png =400x)
_手動テストを自動化する
引用: https://codezine.jp/article/detail/19909_

\
これで、手動テストが多い現状から脱却し、開発プロセスが多少は改善するでしょう。

しかし、E2E テストの比重が大きい状態が長く続くと問題になります。
何故問題か？
E2E テストのデメリットを思い出してください。

- 自動化の難度と複雑性が高い
- テスタビリティへの配慮が難しい
- 高コスト

E2E テストの数が多くなればなるほど、テスト実行時間が長くなり、メンテナンスが難しくなり、不安定な状態に陥ります。
プロダクトの品質は向上するかもしれませんが、開発生産性は減少してしまいます...
（やがて pass しないテストが出てきて、メンテナンスを維持できなくなり、品質を保てなくなるケースも...）

そのため、短期的な施策としては良いですが、どこかのタイミングでテストピラミッドに近づけるための施策を打つ必要があります。

:::details 何故、E2E テストの比重が大きくなってしまうのか？

よくある原因は、**開発チームと QA チームのサイロ化**です。
開発チームと QA チームの距離が遠い組織は多いのではないでしょうか？
\
分断されていると、**開発チームが単体テストの設計・実装を担当し、QA チームが E2E テストの設計・実装を行う**ケースが多いです。
何故なら、手動テストをしていたのは QA なので、自動化も QA がやる流れになります。
\
QA は自分たちの責務に対しベストを尽くそうとするため、結果として E2E テストの比重が多くなってしまうのです。

:::

#### 長期的な戦略

では、どのようにしてピラミッドにしていくのか？

それは、現状の E2E テストに対し、「**結合テストや単体テストで代替できるものを見つける**」ことです。
上位層にあったテストを少しずつ下位層へと分解していくのです。
![](https://storage.googleapis.com/zenn-user-upload/31f228df4a10-20240927.png)
_引用: https://codezine.jp/article/detail/19909_

\
例えば、E2E テストから結合テストへの分解は、モックやスタブを利用することで可能になるかもしれません。

この時に重要なのが、**目的と技術的な制約を混同しない**ことです。
「内部構造の変化が多く、単体テストに不向き」「単体テストに習熟したメンバーがいない」などの理由で、仕方なく E2E テストになっているものと、「これは E2E で検証すべきだ」というものを区別して考えることで、分解がしやすくなるでしょう。

具体的にどう分解していくか？は[こちらの記事](https://logmi.jp/tech/articles/330973#s4)が参考になります。

## E2E テストの始め方

E2E テストが何者か？はある程度理解できました。
しかし、私にはまだ、E2E テストに対して疑問点があります。

「**E2E テストって具体的に何やればいいんだ？？？？**」

このままでは、先輩に「E2E テストのコードを書いといて！」と言われても、具体的に何から始めれば良いのか分かりません。困ります...
何故なのでしょうか？

それは、「**何をどのようにテストすれば良いか？**」を定めていないかです。

### ユーザーストーリー・テストシナリオ・テストケースを定義する

「何をどのようにテストすれば良いか？」は、以下の 3 つを定義することで明らかになります。

- ユーザーストーリー
- テストシナリオ
- テストケース

1. **ユーザーストーリーとは**
   - ソフトウェアの機能や要件を、**ユーザーの視点**から簡潔に記述したもの
   - テストシナリオの基となる
   - 例：「既存ユーザーが EC サイトにログインし、商品を検索して購入する」
2. **テストシナリオとは**
   - 検証したい、「ユーザーの**振る舞い**」を定義したもの
   - ユーザーストーリーに**具体性**を持たせたもの
   - 例：「既存ユーザー（メールアドレス: `user@example.com`、パスワード: `password123`）が EC サイトにログインし、`ワイヤレスイヤホン` を検索する。検索結果から `Sony WF-1000XM4` を選択し、`1` 個をカートに追加する。その後、配送先を `東京都渋谷区テスト町 1-1-1` に設定し、クレジットカード（番号: `4111111111111111`、有効期限: `12/25`、セキュリティコード: `123`）で支払いを行い、注文を完了する」
3. **テストケースとは**
   - **テストシナリオ**を検証するために必要な、各ステップの具体的な検証項目
   - ユーザーの「振る舞い」の中で発生する、特定の「アクション」が検証対象
   - **テストシナリオ**は**テストケース**を内包する
   - **テストケース**は**テストシナリオ**の中に複数存在可能
   - 例：「ログインが正常に完了する」

:::details EC サイトを例にした場合

1. **ユーザーストーリー**
   「既存ユーザーが EC サイトにログインし、商品を検索して購入する」
2. **テストシナリオ**
   「既存ユーザー（メールアドレス: `user@example.com`、パスワード: `password123`）が EC サイトにログインし、`ワイヤレスイヤホン` を検索する。検索結果から `Sony WF-1000XM4` を選択し、`1` 個をカートに追加する。その後、配送先を `東京都渋谷区テスト町 1-1-1` に設定し、クレジットカード（番号: `4111111111111111`、有効期限: `12/25`、セキュリティコード: `123`）で支払いを行い、注文を完了する」
3. **テストケース**
   - ログインが正常に完了する
   - `ワイヤレスイヤホン` の検索結果が正しく表示される
   - `Sony WF-1000XM4` の商品詳細ページが正しく表示される
   - 商品がカートに正常に追加される
   - チェックアウトプロセスで配送先情報が正しく入力できる
   - チェックアウトプロセスで支払い情報が正しく入力できる
   - 注文確認画面で正しい情報が表示される
   - 注文が正常に完了し、確認画面が表示される

:::

### ユーザーストーリー・テストシナリオ・テストケースを定義を基にコードを書く

ユーザーストーリー・テストシナリオ・テストケースの定義が完了しました。
あとはテスティングフレームワークの使い方さえ分かれば、コードを書くのはそんなに難しくないはずです。
前述の EC サイトを例に、Playright でコードを記述してみます。

:::details テストコード

```ts
import { test, expect } from "@playwright/test";

test.describe("ECサイトの購入フローテスト", () => {
  test("既存ユーザーがログインし、商品を検索して購入する（有効系）", async ({
    page,
  }) => {
    // テストシナリオの開始
    await page.goto("https://example-ec-site.com");

    // 1. ログインが正常に完了する
    await page.getByRole("link", { name: "ログイン" }).click();
    await page.getByLabel("メールアドレス").fill("user@example.com");
    await page.getByLabel("パスワード").fill("password123");
    await page.getByRole("button", { name: "ログイン" }).click();
    await expect(page.getByText("ログインしました")).toBeVisible();
    await expect(page.getByText("ユーザー名: テストユーザー")).toBeVisible();

    // 2. 'ワイヤレスイヤホン'の検索結果が正しく表示される
    await page
      .getByRole("searchbox", { name: "商品検索" })
      .fill("ワイヤレスイヤホン");
    await page.getByRole("button", { name: "検索" }).click();
    await expect(
      page.getByRole("heading", { name: "検索結果: ワイヤレスイヤホン" })
    ).toBeVisible();
    await expect(
      page.getByRole("link", { name: "Sony WF-1000XM4", exact: true })
    ).toBeVisible();

    // 3. 'Sony WF-1000XM4'の商品詳細ページが正しく表示される
    await page
      .getByRole("link", { name: "Sony WF-1000XM4", exact: true })
      .click();
    await expect(
      page.getByRole("heading", { name: "Sony WF-1000XM4" })
    ).toBeVisible();

    // 4. 商品がカートに正常に追加される
    await page.getByRole("button", { name: "カートに追加" }).click();
    await expect(page.getByText("カートに追加しました")).toBeVisible();
    await page.getByRole("link", { name: "カートを見る" }).click();
    await expect(
      page.getByRole("heading", { name: "ショッピングカート" })
    ).toBeVisible();
    await expect(page.getByText("Sony WF-1000XM4")).toBeVisible();
    await expect(page.getByRole("spinbutton", { name: "数量" })).toHaveValue(
      "1"
    );

    // 5. チェックアウトプロセスで配送先情報が正しく入力できる
    await page.getByRole("button", { name: "チェックアウト" }).click();
    await page.getByLabel("氏名").fill("テスト ユーザー");
    await page.getByLabel("住所").fill("東京都渋谷区テスト町1-1-1");
    await page.getByLabel("電話番号").fill("03-1234-5678");
    await page.getByRole("button", { name: "次へ" }).click();

    // 6. チェックアウトプロセスで支払い情報が正しく入力できる
    await page.getByLabel("カード番号").fill("4111111111111111");
    await page.getByLabel("有効期限").fill("12/25");
    await page.getByLabel("セキュリティコード").fill("123");
    await page.getByRole("button", { name: "次へ" }).click();

    // 7. 注文確認画面で正しい情報が表示される
    await expect(page.getByRole("heading", { name: "注文確認" })).toBeVisible();
    await expect(page.getByText("Sony WF-1000XM4")).toBeVisible();
    await expect(page.getByText("数量: 1")).toBeVisible();
    await expect(page.getByText("東京都渋谷区テスト町1-1-1")).toBeVisible();
    await expect(page.getByText("カード番号: ************1111")).toBeVisible();

    // 8. 注文が正常に完了し、確認画面が表示される
    await page.getByRole("button", { name: "注文を確定する" }).click();
    await expect(
      page.getByRole("heading", { name: "ご注文ありがとうございます" })
    ).toBeVisible();
    await expect(page.getByText("注文番号:")).toBeVisible();
  });

  // 他のテストシナリオ（無効系など）をここに追加できます
  // 例: test('在庫切れ商品を購入しようとした場合', async ({ page }) => { ... });
  // 例: test('無効なクレジットカード情報で購入しようとした場合', async ({ page }) => { ... });
});
```

:::

`test.describe` にユーザーストーリー（テストシナリオの集まりである「テストスイート」）を定義しています。
`test` には各テストシナリオを単位に記述し、その中にテストケースを満たすコードを記述しています。

## テストコードの可読性を高めるための取り組み

## 【アンチパターン】腐りやすい E2E テスト

### ① 開発サイクルの中で実行しない

何故アンチパターンか？
それは、「**アプリケーションの変更に対してテストが追従できなくなる**」から

開発サイクルの外、つまり、リリースサイクルの中で E2E テストを行うと、リリース直線までシステムの E2E レベルの振る舞いが変更されたかどうかがわからない。

E2E テストのコードが最新の振る舞いに追従しているかどうかも、リリースのタイミングでしか分からなくなる。

開発サイクルの中でも E2E テストが実行され、メンテナンスがされていれば、開発者は自身の変更がシステムレベルの振る舞いを変えていないこと（または、変えていること）をチェックした上で開発を進めることができる。

### ②「振る舞い」に依拠しないテストコード

何故アンチパターンか？
それは、**「頻繁なメンテナンスが必要になる**」からです。

E2E テストは、ユーザーの「**振る舞い**」をテストするものです。
内部構造をテストするものではありません。

「振る舞いをテストしない」とはどういうことか？
以下のフォームの `<input type="submit" value="送信" />` を例に考える。

```html
<form>
  <input type="text" placeholder="名前" />
  <input type="text" placeholder="会社名" />
  <input type="number" placeholder="年齢" />
  <input type="submit" value="送信" />　
</form>
```

テストコードにて、以下はアンチパターン。

```ts
findElement('input[type="submit"]').click();
```

上記は壊れにくい。
`type="submit"` を削除したらテストは失敗する。

以下も若干アンチパターン。

```ts
findElement('input[value="送信"]');
```

実装が `button` タグになったらテストは失敗する。

理想は下記のように、「ボタン」という役割を持つコンポーネントのうち、「送信」ラベルを持つものを探索するコード。

```ts
findElement(role: button, label: "送信").click();
```
