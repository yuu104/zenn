---
title: "【Playwright】テストコードの組み立て方"
---

## test()

`test()` はテストの最小単位を表現する関数です。

```ts
test("テストケース名", async ({ page }) => {
  // テストケース本体
});
```

この基本構造は非常に多くの機能を内包しています：

1. **テスト名**:
   最初の引数には、テストの内容を簡潔に表す説明的な名前を指定します。
2. **非同期関数**:
   第二引数には非同期関数（`async`）を指定します。これにより、`await` キーワードを使用して非同期操作を扱えます。
3. **フィクスチャ**:
   関数の引数（ここでは `{ page }`）は「フィクスチャ」と呼ばれ、Playwright が提供する様々なオブジェクトやユーティリティにアクセスできます。

### フィクスチャについて

`page` オブジェクトは新しいブラウザウィンドウを表します。
これ以外にも、Playwright は以下のようなフィクスチャを提供しています：

- `browser`: ブラウザインスタンス。並列実行のワーカーごとに共有されます。
- `browserName`: 使用中のブラウザ名。
- `context`: テストごとに作られる実行コンテキスト。
- `page`: コンテキストで分離されたテストごとに作られるブラウザのページ。
- `request`: テストごとの Web API 実行のコンテキスト。

これらのフィクスチャは、テスト関数の第一引数としてアクセスできます。

### testInfo

`testInfo`は、テスト実行に関する様々な情報や機能を提供するオブジェクトです。
テスト関数の 2 つ目の引数として利用できます。

- 現在実行中のテストのファイル名や名前、行番号などの情報が含まれています。
- タイムアウトなどの設定値を取得したり更新したりできます。
- 添付ファイル機能を使用できます。これにより、UI モードの結果の[Attachments]タブに添付ファイルを付与できます。

`testInfo`の添付ファイル機能は特に有用で、スクリーンショットやログファイル、その他のデータをテスト結果に添付することができます。これにより、テスト失敗時のデバッグがより容易になります。

## テストのグループ化

テストのグループ化は、テストコードの構造化と管理を容易にする重要な機能です。
Playwright では、`test.describe()`メソッドを使用してテストをグループ化することができます。
これにより、テストの可読性が向上し、関連するテストケースをまとめることができます。

グループ化には以下のメリットが存在します :

1. **コードの整理**: 関連するテストケースを論理的にまとめることができます。
2. **準備コードの削減**: グループ内で共通の設定や前処理を一箇所にまとめられます。
3. **テストの集中管理**: 特定の機能や画面に関するテストを集中的に管理できます。
4. **可読性の向上**: テストの構造が明確になり、全体の把握が容易になります。

Playwright でのテストのグループ化は、以下のように`test.describe()`を使用して行います：

```javascript
import { test } from "@playwright/test";

test.describe("一覧ページ", () => {
  test("一覧表示", async () => {
    // テストコード
  });

  test("個別表示", async () => {
    // テストコード
  });
});
```

この例では、「一覧ページ」というグループの中に「一覧表示」と「個別表示」という 2 つのテストケースがグループ化されています。

:::message
**ビヘイビア駆動開発（BDD）との関連**

`test.describe()`メソッドは、ビヘイビア駆動開発（BDD）の考え方に基づいています。
BDD はソフトウェア開発手法の一つで、「振る舞い」を中心にシステムの仕様を記述し、開発を進める方法です。
BDD は、テストコードを単なる検証ツールではなく、ソフトウェアの仕様を表現する「生きたドキュメント」として扱います。

BDD のテストを構成する要素として`describe`と`it`があります：

- `describe(〇〇)`: テスト対象（名詞）を指定
  〇〇をこれから説明します。
- `it(〇〇)`: それが行う動作（動詞）を指定
  それは〇〇という動きをします。

例えば：

```javascript
describe("ログイン画面", () => {
  it("正しいユーザーIDとパスワードを受け付けてログインさせる", () => {
    // テストコード
  });

  it("間違ったユーザーIDとパスワードではエラーを表示する", () => {
    // テストコード
  });
});
```

このような構造により、テストコードが自然言語に近い形で記述でき、テストの意図が明確になります。

Playwright は、`test.describe()`と`test()`を提供しており、これらは BDD の`describe`と`it`に相当します。

:::

## 準備・片付けコードを共有する

Playwright では、テストの準備や片付けのためのコードを効率的に管理するための特別なメソッドが提供されています。これらのメソッドを使用することで、複数のテスト間で共通の設定や後処理を簡単に共有できます。

Playwright は以下の 4 つの主要なフック関数を提供しています：

1. `test.beforeAll()`: 全てのテストの実行前に一度だけ実行されます。
2. `test.beforeEach()`: 各テストケースの実行前に毎回実行されます。
3. `test.afterEach()`: 各テストケースの実行後に毎回実行されます。
4. `test.afterAll()`: 全てのテストの実行後に一度だけ実行されます。

これらの関数を使用することで、テストの準備や後処理を効率的に行うことができます。

例えば、各テストの前にログイン処理を行いたい場合、以下のように`test.beforeEach()`を使用できます：

```javascript
test.beforeEach(async () => {
  await ログイン();
});
```

この設定により、各テストケースの実行前に自動的にログイン処理が行われます。

これらのフック関数は、テストファイル内で定義された順序に従って実行されます。
例えば、以下のようなコード構造がある場合：

```javascript
import { test } from "@playwright/test";

test.beforeEach("親 beforeEach", () => {});
test.beforeAll("親 beforeAll", () => {});
test.afterEach("親 afterEach", () => {});
test.afterAll("親 afterAll", () => {});

test("親テスト", async ({ page }) => {});

test.describe("テストスイート", () => {
  test.beforeEach("子 beforeEach", () => {});
  test.beforeAll("子 beforeAll", () => {});
  test.afterEach("子 afterEach", () => {});
  test.afterAll("子 afterAll", () => {});
  test("子テスト", async ({ page }) => {});
});
```

親テストの実行順序は以下のようになります :

1. 親 beforeAll
2. 親 beforeEach
3. 親テスト
4. 親 afterEach
5. 親 afterAll

子テストの実行順序は以下のようになります：

1. 親 beforeAll
2. 子 beforeAll
3. 親 beforeEach
4. 子 beforeEach
5. 子テスト
6. 子 afterEach
7. 親 afterEach
8. 子 afterAll
9. 親 afterAll

:::message

親テストと子テストは並列で実行される可能性があります。
そのため、どちらが先に実行されるかは状況によって変わる可能性があります。

`beforeAll()`や`afterAll()`などのフック関数は、全てのテストで共有される処理を行うため、テストスイート（`describe()`ブロック）またはグローバルスコープごとに並行して実行されます。

テストコードを書く際は、親テストと子テストの実行順序に依存しないように注意する必要があります。

:::
