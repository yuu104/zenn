---
title: "計測と振り返り"
---

## なぜ「計測」と「振り返り」をするのか？

- 導入コストに見合った成果を得られるかを知るため
- 施策の方向性が妥当だったのかを知るため
- 「何となく導入したまま、やがてメンテナンスされなくなる...」という状態をなくすため

## 「計測」と「振り返り」のポイント

1. **継続的に計測し続ける**
   低頻度な計測はアンチパターンです。

   - 一度きりだけ計測する
   - 毎月末に行われる全大会で発表するために、月に 1 回計測する

   \
    「計測頻度が低い」→ 「振り返りの頻度が低い」→ 「軌道修正のタイミングが少ない」
   ということです。
   そうなると、一度に行う意思決定の影響範囲が大きくなります。それ故に、意思決定までの時間が長くなります。
   \
   頻度高く継続的に計測し続けることにより、起動修正を重ねながら常に良い方向に向かうようにチームを調整し続けることができます。
   ![](https://storage.googleapis.com/zenn-user-upload/917140e783e5-20241020.png)

2. **自動化する**
   頻度高く継続的に計測するために重要なことは何でしょうか？
   そう、**自動化**です。
   テスト実行の度に集計されるような仕組みがあれば、継続的な計測は簡単になります。
   \
   自動化する際は、まず次のような取り組みから始めると良いでしょう。
   - 自動計測しやすいメトリクス（計測項目）から始め、トレンドを把握する
   - とにかくデータを収集する
3. **振り返る**
   計測する「だけ」で終わってはいけません。
   必ず定期的に振り返り、施策が正しい方向に向かっているかを確認しましょう。
4. **一度にすべてをやる必要はない**
   最初からすべてのメトリクスを揃える必要はありません。
   重要なのは、**メトリクスを 1 つでもいいから自動計測し、定期的に振り返る**ことです。
   振り返りを通じて、追加で必要なメトリクスを検討する形で進めましょう。

## 主要メトリクス

自動テストの目的として、「**安全にリリースできる状態を、持続可能なコストにキープし続ける**」がありました。
メトリクスの設定にあたり、この目的を意識すると良いでしょう。

### カバレッジ

テストがある項目をどれだけカバーしているかを表します。
分母となる「**カバレッジアイテム**」の総数に対して、カバーされているアイテムがどれだけあるのかを計測します。

分母となるカバレッジアイテムには様々なものが用いられ、それぞれに向き不向きがあります。
今回は、以下二つのカバレッジアイテムを紹介します。

1. **コードカバレッジ**

   - ソースコードに対するカバレッジ
   - テスト実行によって**コードの行や分岐が十分に実行されたかどうか**を測る
   - **ソフトウェアが正しく動作しているかについては評価しない**

   \
    つまり、コードカバレッジはあくまでテストがコードの中のどれだけの部分をカバーできたかを表す指標にすぎません。
   よって

   - 「カバレッジが高い」ことは仕様を十分にカバーしていることを意味しません
     :::details 具体例
     電話番号を入力するフォームを対象に考える。
     バリデーションは HTML の正規表現を利用する。
     つまり、ブラウザ側が勝手にバリデーションしてくれるので、アプリケーションコードにバリデーションロジックの記述は存在しない。
     \
     この場合、1 つのテストケースだけでコードカバレッジが 100%になる。
     しかし、ブラウザ機能に任せているバリデーションチェックが正しく動作しているかの検証はしていない。
     よって、この状態はアプリケーションの仕様を十分にカバーしたテストができているとは限らない。
     :::
   - 「カバレッジが低い」ことはテストが不十分であるとは言い切れません
     :::details 具体例
     デッドコード（どのような手順を取っても到達しないコード）が多い場合、カバレッジは低くなる。
     しかし、このような場合はテストが不十分であるわけではない。
     :::

   :::message
   **コードカバレッジの種類**

   1. **C0 カバレッジ（ステートメントカバレッジ）**

      - コードの各行がテストで実行されたかどうかを計測する
      - 全ての行が一度でも実行されれば、カバレッジは 100%となる

   2. **C1 カバレッジ（ブランチカバレッジ）**
      - コードの各分岐（if 文や switch 文など）がテストで実行されたかどうかを計測する
      - すべての分岐が一度でも実行されれば、カバレッジは 100%となる
   3. **パスカバレッジ**
      - すべての可能なパス（特定の関数やメソッド、ブロック）がテストで実行されたかどうかを計測する
      - すべてのパスが少なくとも一度は実行されれば、パスカバレッジは 100%となる

   :::

   計測方法としてはツールを利用します。
   Node.js では「istanbl」という、テスト実行中に実行された行を計測するようなツールが存在する。

2. **ユーザーストーリーカバレッジ**

   - アプリケーションに期待される機能や振る舞いに対するカバレッジ
   - **ユーザーストーリー**をカバレッジアイテムとする
   - これまでに作成したユーザーストーリーのうち、どれだけがテストコードでカバーされているかを確認する

   ユーザーストーリーカバレッジは、機械的に算出するものではありません。
   ユーザーストーリーとテストケースを関連付けて算出します。

   主要な方法として、JIRA などのチケット管理システムと併用してカバレッジを算出することができます。
   開発チケットのサブタスクとして自動テスト用のチケットを作成し、`完了したサブタスクの数/サブタスクの総数` で算出します。

### Flaky Test の数

Flaky Test はできるだけ減らしたです。
そのため、しっかり計測して数を減らしていくことが重要です。

### Four Keys

Four Keys は、ソフトウェアの開発生産性（デリバリーパフォーマンス）を示す指標で、以下の 4 つで構成されています。

- **デプロイ頻度** : 本番環境へ正常にデプロイした頻度
- **変更のリードタイム** : コミットから本番環境へ反映するまでの所要時間
- **変更失敗率** : 本番環境に変更を加えた結果、障害が発生した割合
- **サービス復元時間** : 障害から復旧するまでの所要時間

Google の DevOps Research and Assessment（DORA）が提唱しました。

デプロイ頻度と変更リードタイムは**速度**の指標で、変更障害率とサービス復元時間は**安定性**の指標です。
開発チームはこれらの値を計測して、継続的に改善を繰り返すことでビジネス成果を向上させることができます。

あくまで DevOps のパフォーマンスを示すものですが、E2E テストの効果を間接的に計測する指標としても捉えることができます。

1. **デプロイ頻度**

   - 本番環境への正常なデプロイ頻度を表すメトリクス
   - 「デプロイが成功した時点」のデータを用いる
   - 一般的に、**デプロイ頻度が高くなる程、一度に変更される量は少なくなり、変更によるリスクは少なくなる**

2. **リードタイム**

   - コミットから本番環境へ反映され、ユーザーに届くまでの所要時間を表すメトリクス
   - 「コミット発生時点」と「デプロイ実行時点」のデータを用いる
   - **コード変更以外の作業でどの程度手間が発生しているかを表している**

3. **変更失敗率**

   - デプロイが原因で本番環境で障害が発生する割合を表すメトリクス
   - 「試行されたデプロイ数」と「障害が発生したデプロイ数」のデータを用いる
   - **変更失敗率が高い → 変更に対して十分にテストされていないことを示唆する**

4. **サービス復元時間**

   - 織が本番環境での障害から回復するのにかかる時間を表すメトリクス
   - 「インシデント作成時点」と「インシデント解決時点」のデータを用いる
   -

これら 4 つのメトリクスは相互に関係しているため、どれか 1 つが優秀であればよいわけではありません。

- デプロイ頻度が高くても、変更失敗率が高ければ、テスト不足のプロダクトを高頻度にデプロイしているだけです
- デプロイ頻度が高くても、リードタイムが長ければ、デプロイ頻度の高さが高速なデリバリーに繋がっていないことを示します

### バグの件数

「バグを減らす」のも自動テストの目的の一つです。
そのため、バグ件数は最も直接的なメトリクスです。

ここでいう「バグ」とは、本番環境で見つかったものを指します。

## 振り返り

### 振り返りの定義

**自分たちがよい方向に向かっているかどうかを確認すること**

ただ計測するだけでなく、振り返りを通してテストや開発プロセス全体のボトルネックを明らかにし、継続的な改善を行いましょう。

### 振り返りの具体例

### デプロイ頻度は高いが、バグ件数や変更失敗率も高い

1. **使用したメトリクス**
   - Four Keys
   - バグ件数
2. **計測結果**
   - デプロイ頻度は高い
   - バグ件数が多い
   - 変更失敗率が高い
3. **判明した課題**
   - バグ件数が多い
   - 変更失敗率が高い
4. **課題の原因に対する仮説**
   - リリース前のテストが十分でない
5. **改善したいこと**
   - バグ件数を少なくする
   - 変更失敗率を下げる
6. **次のアクション**
   - コードカバレッジ・ユーザーストーリーカバレッジを計測する
   - 変更の度にカバレッジが向上するようにすることで、テストによる品質の向上を目指す
   - カバレッジが向上しても現状の課題が改善しなければ、テスト分析の不足や、コード品質の見直しが必要になる

#### ユーザーストーリーカバレッジは向上しているが、Flaky Test は改善されない

1. **使用したメトリクス**
   - ユーザーストーリーカバレッジ
   - Flaky Test の数
2. **計測結果**
   - ユーザーストーリーカバレッジは向上している
   - Flaky Test の数が向上している
3. **判明した課題**
   - Flaky Test の数が多くなっており、テストの信頼性が下がっている
4. **課題の原因に対する仮説**
   - 壊れやすいテストを作っている
5. **改善したいこと**
   - Flaky Test の数を減らし、テストの信頼性を高める
6. **次のアクション**
   - テストの独立性や冪等性を高める
   - コードカバレッジを計測し、E2E 以外のテストレベルをチェックする
