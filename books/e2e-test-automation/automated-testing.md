---
title: "自動テスト"
---

## 自動テストは開発サイクルの中で行う

「テスト自動化」では「自動テスト」における以下のメリットを握りつぶしてしまう。

- 開発者がテストによるフィードバックを素早く受けられるため、リリースサイクルを短縮できる

何故か？
それは、開発サイクルの外側であるリリースサイクルで、リグレッションテストを行うからである。
![](https://storage.googleapis.com/zenn-user-upload/2f8c0323a94c-20240923.png)
単にリグレッションテストを自動化しても、バグを発見した際に再度開発サイクルにて戻る必要が出てくる。
リリースサイクルの中では、開発者がテストによるフィードバックを素早く受けられず、リリースサイクルは短縮されない。

### ローカル環境で実行する

- コードを変更したら、自動テストを**ローカル環境**で実行する
- すべてのテストケースがパスしたら、「何も壊れていない」ということが**開発環境で**分かる
- 「壊れていない」ことをすぐに検証できるため、リファクタリングもしやすくなる
- Pull Request する時点で、開発者は品質に自信を持った状態でいられる

### Pull Request 時、ステージング環境のデプロイ時にも実行する

CI ツールを用い、ローカル環境だけでなく、**様々なタイミングで継続的に**実行する。

1. **Pull Request 作成後**
   - CI によるチェックが完了した状態で main ブランチにマージできる
2. **マージ後**
   - main ブランチには複数人の変更が入るため、何かが壊れている事態も考えられる
   - CI によりここでもチェックしておく
3. **ステージング環境のデプロイ時**
   - 本番環境に近い環境でもテストする
   - このタイミングでしか実行できないテストも存在する

## 自動テストは「どう動くのか」を開発者に説明してくれる

自動テストは、バグを検知してくれるだけではない。
アプリケーションが「**どう動くのか**」を開発者に説明するドキュメントにもなる。

### 単体テストでの例

以下は、「消費税込みの金額を計算する」関数。
税抜きの値段 `price` と税率 `rate` を引数として受け取る。

```ts
calculateTax(price: number, rate: 0.1)
```

他の開発者が見た場合、以下のような疑問が挙がる。

- 0 以下の値段を渡すとどうなるか？
- マイナスの税率を渡すとどうなるか？
- 端数がでる場合はどうなるか？

単体テストがないと、以下のように手動で確認する必要がある。

```ts
> calculateTax(price:0, rate:0.1)

> InvalidArgumentError('price は 1 以上にしてください')


> calculateTax(price:0. rate:-0.1)

> InvalidArgumentError('rate は 0 または正の数にしてください')


> calculateTax(price:10, rate:0.5)

> 11 // 切り上げられている


> calculateTax(price:10, rate:0.4)

> 10 // 切り捨てられている、つまりこの関数は四捨五入
```

しかし、単体テストを記述すると、これがドキュメントとなる。

```ts
test('税込みの金額を返す') {
  assert(calculateTax(price:100, rate:10)).expect(110)
}

test('金額が 0 ならエラー') {
  assert(calculateTax(price:0, rate:0.1)).expect(InvalidArgumentError)
}

test('税率がマイナスならエラー') {
  assert(calculateTax(price:100, rate:-0.1)).expect(InvalidArgumentError)
}

test('端数は四捨五入される') {
  assert(calculateTax(price:10, rate:0.5)).equal(11)
  assert(calculateTax(price:10, rate:0.4)).equal(10)
}
```

### E2E テストでの例

E2E テストは、ある画面がどのように使われるかが、コードとして記述されている。
コードを読めば、**ユーザーの具体的なユースケース**を理解できる。

## 自動テスト導入は「CI/CD パイプラインの構築」から始める

「自動テスト」と聞くと、まず初めにテストコードを沢山書くイメージだと思います。
しかし、**たった 1 つのテストケースでいいから、まずは自動化されている状態を作ることをお勧めします**。

:::message
**何故パイプライン構築が先なのか？**

「アプリケーションを常に検証できる状態を作る」ことが重要でだからです。
CI/CD パイプラインは自動テストを実行するための「場所」を提供してくれるものです。
パイプラインがなければ、自動テストを実行する環境や仕組みがありません。

そして、パイプラインが構築されていれば、最初は 1 つのテストから始めたとしても、徐々にテストを追加していくことは容易です。あとはテストコードを書くだけですからね!

このように、初期段階で自動テストしやすい環境を作っておくことで、自動テストの導入ハードルを下げることができるのです！！！

:::

そのために、CI/CD パイプラインの導入を最優先で行うのです。

:::details あれ、そもそも「CI/CD パイプライン」って何だったっけ？

ソフトウェアのマージからリリースまでの自動化された一連のプロセスを指します。
自動化により、ソフトウェア開発が効率化され、品質が上がり、リリース速度の向上を期待できます。

1. **CI（Continuous Integration：継続的インテグレーション）とは**
   - 変更のマージ、ビルド、およびテストを自動化すること
   - 自動化されたビルドとテストにより、開発者は手動での作業やテストの重複を省くことができ、効率的な開発プロセスを実現
   - 例：コードをプッシュするたびに自動的にビルドされ、テストが実行される
2. **CD（Continuous Delivery/Deployment：継続的デリバリー/デプロイメント）**
   - 変更のマージからリリース（デプロイ）までを自動化すること
   - CI を含む概念
   - 例：テストが成功したら自動的にステージング環境にデプロイされる
3. **CI/CD パイプラインの基本的な流れ**
   1. コードのプッシュ/プルリクエスト
   2. コードのビルド
   3. 自動テストの実行
   4. （オプション）セキュリティチェック
   5. ステージング環境へのデプロイ
   6. （承認後）本番環境へのデプロイ
4. **メリット**
   - バグの早期発見と修正
   - 開発速度の向上
   - 品質の一貫性確保
   - 手動作業の削減によるヒューマンエラーの防止

CI/CD パイプラインを導入することで、1 つのテストケースから始めて徐々に自動テストを拡充していくことができます。
これにより、開発プロセス全体の効率化と品質向上を実現できるのです。

\
CI/CD についての詳細は[こちら](https://circleci.com/ja/blog/what-is-ci-cd/)。

:::
