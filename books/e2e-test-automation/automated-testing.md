---
title: "自動テストとは何か？"
---

ただ手動テストを自動化する「テスト自動化」はアンチパターンである。
では、「自動テスト」は具体的にどのように行うのか？

## 自動テストは開発サイクルの中で行う

「テスト自動化」では「自動テスト」における以下のメリットを握りつぶしてしまう。

- 開発者がテストによるフィードバックを素早く受けられるため、リリースサイクルを短縮できる

何故か？
それは、開発サイクルの外側であるリリースサイクルで、リグレッションテストを行うからである。
![](https://storage.googleapis.com/zenn-user-upload/2f8c0323a94c-20240923.png)
単にリグレッションテストを自動化しても、バグを発見した際に再度開発サイクルにて戻る必要が出てくる。
リリースサイクルの中では、開発者がテストによるフィードバックを素早く受けられず、リリースサイクルは短縮されない。

### ローカル環境で実行する

- コードを変更したら、自動テストを**ローカル環境**で実行する
- すべてのテストケースがパスしたら、「何も壊れていない」ということが**開発環境で**分かる
- 「壊れていない」ことをすぐに検証できるため、リファクタリングもしやすくなる
- Pull Request する時点で、開発者は品質に自信を持った状態でいられる

### Pull Request 時、ステージング環境のデプロイ時にも実行する

CI ツールを用い、ローカル環境だけでなく、**様々なタイミングで継続的に**実行する。

1. **Pull Request 作成後**
   - CI によるチェックが完了した状態で main ブランチにマージできる
2. **マージ後**
   - main ブランチには複数人の変更が入るため、何かが壊れている事態も考えられる
   - CI によりここでもチェックしておく
3. **ステージング環境のデプロイ時**
   - 本番環境に近い環境でもテストする
   - このタイミングでしか実行できないテストも存在する

## 自動テストは「どう動くのか」を開発者に説明してくれる

自動テストは、バグを検知してくれるだけではない。
アプリケーションが「**どう動くのか**」を開発者に説明するドキュメントにもなる。

### 単体テストでの例

以下は、「消費税込みの金額を計算する」関数。
税抜きの値段 `price` と税率 `rate` を引数として受け取る。

```ts
calculateTax(price: number, rate: 0.1)
```

他の開発者が見た場合、以下のような疑問が挙がる。

- 0 以下の値段を渡すとどうなるか？
- マイナスの税率を渡すとどうなるか？
- 端数がでる場合はどうなるか？

単体テストがないと、以下のように手動で確認する必要がある。

```ts
> calculateTax(price:0, rate:0.1)

> InvalidArgumentError('price は 1 以上にしてください')


> calculateTax(price:0. rate:-0.1)

> InvalidArgumentError('rate は 0 または正の数にしてください')


> calculateTax(price:10, rate:0.5)

> 11 // 切り上げられている


> calculateTax(price:10, rate:0.4)

> 10 // 切り捨てられている、つまりこの関数は四捨五入
```

しかし、単体テストを記述すると、これがドキュメントとなる。

```ts
test('税込みの金額を返す') {
  assert(calculateTax(price:100, rate:10)).expect(110)
}

test('金額が 0 ならエラー') {
  assert(calculateTax(price:0, rate:0.1)).expect(InvalidArgumentError)
}

test('税率がマイナスならエラー') {
  assert(calculateTax(price:100, rate:-0.1)).expect(InvalidArgumentError)
}

test('端数は四捨五入される') {
  assert(calculateTax(price:10, rate:0.5)).equal(11)
  assert(calculateTax(price:10, rate:0.4)).equal(10)
}
```

### E2E テストでの例

E2E テストは、ある画面がどのように使われるかが、コードとして記述されている。
コードを読めば、**ユーザーの具体的なユースケース**を理解できる。

## 自動テスト導入は「CI/CD パイプラインの構築」から始める

「自動テスト」と聞くと、まず初めにテストコードを沢山書くイメージだと思います。
しかし、**たった 1 つのテストケースでいいから、まずは自動化されている状態を作ることをお勧めします**。

:::message
**何故パイプライン構築が先なのか？**

「アプリケーションを常に検証できる状態を作る」ことが重要でだからです。
CI/CD パイプラインは自動テストを実行するための「場所」を提供してくれるものです。
パイプラインがなければ、自動テストを実行する環境や仕組みがありません。

そして、パイプラインが構築されていれば、最初は 1 つのテストから始めたとしても、徐々にテストを追加していくことは容易です。あとはテストコードを書くだけですからね!

このように、初期段階で自動テストしやすい環境を作っておくことで、自動テストの導入ハードルを下げることができるのです！！！

:::

そのために、CI/CD パイプラインの導入を最優先で行うのです。

:::details あれ、そもそも「CI/CD パイプライン」って何だったっけ？

ソフトウェアのマージからリリースまでの自動化された一連のプロセスを指します。
自動化により、ソフトウェア開発が効率化され、品質が上がり、リリース速度の向上を期待できます。

1. **CI（Continuous Integration：継続的インテグレーション）とは**
   - 変更のマージ、ビルド、およびテストを自動化すること
   - 自動化されたビルドとテストにより、開発者は手動での作業やテストの重複を省くことができ、効率的な開発プロセスを実現
   - 例：コードをプッシュするたびに自動的にビルドされ、テストが実行される
2. **CD（Continuous Delivery/Deployment：継続的デリバリー/デプロイメント）**
   - 変更のマージからリリース（デプロイ）までを自動化すること
   - CI を含む概念
   - 例：テストが成功したら自動的にステージング環境にデプロイされる
3. **CI/CD パイプラインの基本的な流れ**
   1. コードのプッシュ/プルリクエスト
   2. コードのビルド
   3. 自動テストの実行
   4. （オプション）セキュリティチェック
   5. ステージング環境へのデプロイ
   6. （承認後）本番環境へのデプロイ
4. **メリット**
   - バグの早期発見と修正
   - 開発速度の向上
   - 品質の一貫性確保
   - 手動作業の削減によるヒューマンエラーの防止

CI/CD パイプラインを導入することで、1 つのテストケースから始めて徐々に自動テストを拡充していくことができます。
これにより、開発プロセス全体の効率化と品質向上を実現できるのです。

\
CI/CD についての詳細は[こちら](https://circleci.com/ja/blog/what-is-ci-cd/)。

:::

## 【アンチパターン】腐りやすい E2E テスト

### 開発サイクルの中で実行しない

何故アンチパターンか？
それは、「**アプリケーションの変更に対してテストが追従できなくなる**」から

開発サイクルの外、つまり、リリースサイクルの中で E2E テストを行うと、リリース直線までシステムの E2E レベルの振る舞いが変更されたかどうかがわからない。

E2E テストのコードが最新の振る舞いに追従しているかどうかも、リリースのタイミングでしか分からなくなる。

開発サイクルの中でも E2E テストが実行され、メンテナンスがされていれば、開発者は自身の変更がシステムレベルの振る舞いを変えていないこと（または、変えていること）をチェックした上で開発を進めることができる。

### 振る舞いをテストしない

何故アンチパターンか？
それは、**「頻繁なメンテナンスが必要になる**」から。

自動テストは、ソフトウェアの振る舞いをテストするもの。
内部構造をテストするものではない。

E2E テストにおいて、「振る舞いをテストしない」とはどういうことか？
以下のフォームの `<input type="submit" value="送信" />` を例に考える。

```html
<form>
  <input type="text" placeholder="名前" />
  <input type="text" placeholder="会社名" />
  <input type="number" placeholder="年齢" />
  <input type="submit" value="送信" />　
</form>
```

テストコードにて、以下はアンチパターン。

```ts
findElement('input[type="submit"]').click();
```

上記は壊れにくい。
`type="submit"` を削除したらテストは失敗する。

以下も若干アンチパターン。

```ts
findElement('input[value="送信"]');
```

実装が `button` タグになったらテストは失敗する。

理想は下記のように、「ボタン」という役割を持つコンポーネントのうち、「送信」ラベルを持つものを探索するコード。

```ts
findElement(role: button, label: "送信").click();
```

:::message
**内部構造ではなく、「振る舞い」に依存したテストコードを書くことで、変更に強くできる。**
そもそも、E2E テストはユーザーの「振る舞い」を検証するもの。
:::
