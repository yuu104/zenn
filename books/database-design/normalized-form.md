---
title: "正規化"
---

- データの整合性と効率性を向上させるための手法
- データベース内のテーブルを効果的に構造化し、データの重複や不整合を最小限に抑える
- 正規化により、データベースの管理と操作が容易になり、データの信頼性が向上する
- 正規化されたものは**正規形**と呼ぶ

## 目的

- データの**一貫性**と**整合性**を維持する
- 重複データを排除する
- データの効率的な検索と更新を可能にする
- データの柔軟性を向上させる

## 正規化の手法

![](https://storage.googleapis.com/zenn-user-upload/3908552a2b66-20230909.png)

- 正規化のステップとしては、第 1 正規化、第 2 正規化、第３正規化、....
- 段階を踏んでいく毎に細分化されていく
- 基本的には第３正規化までやる

## 関数従属性

- ある属性 X を決めると、他の属性 Y の値が一意に決まる場合、「Y は X に関数従属している」
- X -> Y と表現する
- X を**決定項**、Y を**被決定項**と呼ぶ

![](https://storage.googleapis.com/zenn-user-upload/966c236385ed-20230909.jpg)

次の例のように決定項や被決定項が複数の属性の組合せになる場合もある。

![](https://storage.googleapis.com/zenn-user-upload/88ee09a85380-20230909.jpg)

実は正規化とは、テーブルすべての列が**関数従属性**を満たすように整理していくことである。

### 部分関数従属

以下のように**候補キーの一部**に関数従属している状態を「部分関数従属している」という。

![](https://storage.googleapis.com/zenn-user-upload/792178ab9f39-20230909.png)

### 完全関数従属

- 任意の属性が**複数の候補キー全体**に関数従属している状態のこと
- つまり、その列を決定するためには複合キーのすべての列が必要
- 例えば、社員番号と部署コードから社員の名前が特定でき、かつ社員番号や部署コード単独では名前を特定できない場合、社員番号と部署コードは名前に完全関数的に従属している

### 推移的関数従属

A が B に関数的に従属し、B が C に関数的に従属する場合、A が C に対して推移的関数従属していると言いう。

![](https://storage.googleapis.com/zenn-user-upload/403df4d9525e-20230909.png)

## 非正規形

以下の伝票票を元に、正規化を行う。

![](https://storage.googleapis.com/zenn-user-upload/7a7702681253-20230909.png)

この受注伝票 1 枚が 1 件のレコードに相当するとし、並べてみる。

![](https://storage.googleapis.com/zenn-user-upload/956242a2d8a8-20230909.png)

上記のように、1 行の中に複数の繰り返し項目が存在するような表は**非正規形**と呼ぶ。
これでは、各レコードの長さがバラバラで、綺麗な 2 次元の表になってない。
リレーショナルデータベースでは、レコードとしてデータを追加していく操作には適しているが、横方向へ増える非正規形の表は管理することができないため、正規化をしていく必要がある。

## 第 1 正規形

### 定義

**一つのセルの中には一つの値しか含まない**

**社員テーブル**
| 会社コード | 会社名 | 社員 ID | 社員名　 | 年齢 | 部署コード | 部署名 |
| ---------- | ------ | ------- | -------- | ---- | ---------- | ------ |
| C0001 | A 商事 | 000A | 中島 | 40 | D01 | 開発 |
| C0001 | A 商事 | 000B | 藤本 | 32 | D02 | 人事 |
| C0001 | A 商事 | 001F | 三島 | 50 | D03 | 営業 |
| C0002 | B 科学 | 000A | 斉藤 | 47 | D03 | 営業 |
| C0002 | B 科学 | 009F | 田島 | 25 | D01 | 開発 |
| C0002 | B 科学 | 010A | 渋谷 | 33 | D04 | 総務 |

上記のように、一つのセルに一つだけの値が含まれているとき、その値を「**スカラ値（scalar value）**」と呼ぶ。
scalar は「単一の」という意味の英単語。

### 第１正規化を行う

以下の非正規形に対して第１正規化を行う。

**`扶養者`テーブル**
| 社員 ID | 社員名 | 子 |
| ------- | ------ | -------------- |
| 000A | 加藤 | 達夫, 信二 |
| 000B | 藤本 | |
| 001F | 三島 | 敦, 陽子, 清美 |

上記では、`子` 属性に複数の値が入っている。
これは、「一つのセルの中には一つの値しか含まない」という状態に反しており、RDB では重大な規則違反になる。

そのため、下記のように正規化を行う。

| 社員 ID | 社員名 | 子   |
| ------- | ------ | ---- |
| 000A    | 加藤   | 達夫 |
| 000A    | 加藤   | 信二 |
| 000B    | 藤本   |      |
| 001F    | 三島   | 敦   |
| 001F    | 三島   | 陽子 |
| 001F    | 三島   | 清美 |

上記は、`子` の数だけレコードを増やすことにより「一つのセルの中には一つの値しか含まない」という条件を満たしている。

しかし、上記のテーブルには以下 2 つの問題がある。

1. **主キーを決められない**
   任意の 1 レコードを特定しようとすると、`{社員ID, 社員名, 子}` の全ての属性を指定する必要がある。
   `{社員ID, 社員名}` だけだと、「`社員ID` = `00A`」「`社員名` = `加藤`」のように指定した場合に、2 レコードが該当してしまう。
   また、`{社員ID, 社員名, 子}` を主キーとした場合でも、`子` は `NULL` になる可能性がある。
   :::message
   **ポイント**
   主キーには `NULL` が含むのを許可していない。
   :::
2. **テーブルの意味やレコードの単位をすぐに理解できない**
   先ほどのテーブルでは意味的に「社員」と「扶養者」というエンティティの情報を含んでしまっており、テーブルの意味やレコードの単位をすぐに理解できない。

上記 2 つの問題を解決するには、以下のようにテーブルを分ける必要がある。

**`社員`テーブル**
| 社員 ID | 社員名 |
| ----- | ----- |
| 000A | 加藤 |
| 001F | 三島 |

**`扶養者`テーブル**
| 社員 ID | 子 |
| ----- | --- |
| 000A | 達夫 |
| 000A | 信二 |
| 001F | 敦 |
| 001F | 陽子 |
| 001F | 清美 |

:::message
**なぜ一つのセルに複数のセルに値を入れてはダメなのか？**

**セルに複数の値を許せば、主キーが各列の値を一意に決定できないから**

| 社員 ID | 社員名 | 子             |
| ------- | ------ | -------------- |
| 000A    | 加藤   | 達夫, 信二     |
| 000B    | 藤本   |                |
| 001F    | 三島   | 敦, 陽子, 清美 |

上記の非正規形では、主キーである `社員ID` が `子` を一意に特定することができない。
上記では `{社員ID}` -> `{社員名}` という関数従属が成立している。
しかし、`{社員ID}` -> `{子}` という関数従属は不成立となっている。

:::

## 第 2 正規形

下記テーブルに対し、第 2 正規化を行う。

**社員テーブル**
| 会社コード | 会社名 | 社員 ID | 社員名　 | 年齢 | 部署コード | 部署名 |
| ---------- | ------ | ------- | -------- | ---- | ---------- | ------ |
| C0001 | A 商事 | 000A | 中島 | 40 | D01 | 開発 |
| C0001 | A 商事 | 000B | 藤本 | 32 | D02 | 人事 |
| C0001 | A 商事 | 001F | 三島 | 50 | D03 | 営業 |
| C0002 | B 科学 | 000A | 斉藤 | 47 | D03 | 営業 |
| C0002 | B 科学 | 009F | 田島 | 25 | D01 | 開発 |
| C0002 | B 科学 | 010A | 渋谷 | 33 | D04 | 総務 |

- 主キー（候補キー）: `{会社コード, 社員ID}`

### 第 2 正規形の条件

1. **第 1 正規形の条件を満たしている**

   - 第 1 正規化の条件は、「**一つのセルの中には一つの値しか含まない**」
   - 上記テーブルは、この条件を満たしている

2. **全ての非キー属性が候補キーに対して完全関数従属している**
   候補キーに対して、部分関数従属しているものを取り除き、完全関数従属のみのテーブルになっている状態。

   上記のテーブルは、この条件を満たしていない。

   - 候補キーは `{会社コード, 社員ID}`
   - 他のカラムは候補キーに従属している
   - しかし、`{会社コード}` → `{会社名}` の関数従属性がある
   - そのため、このテーブルには部分関数従属が存在し、完全関数従属のみのテーブルではない

   従って、このテーブルに対して第 2 正規化を行う必要がある。

### 第 2 正規化すべき条件

以下の 3 つ全ての条件を満たす場合、第 2 正規化をする必要がある。

1. 一つのセルの中には一つの値しか含まれていない
2. 候補キー（主キー）が複合キーである
3. 複合キーの一部で一意に決定するカラムが存在する（候補キーに対して部分関数従属するカラムが存在する）

:::message
**ポイント**
第 2 正規形は、部分関数従属を解消することで得られる
:::

### 第 2 正規化を行う

- 第 2 正規化を行う → テーブルから部分関数従属を解消する
- 部分関数従属を解消する手段 → テーブルを分割する

**`社員`テーブル**
| 会社コード | 会社名 | 社員 ID | 社員名　 | 年齢 | 部署コード | 部署名 |
| ---------- | ------ | ------- | -------- | ---- | ---------- | ------ |
| C0001 | A 商事 | 000A | 中島 | 40 | D01 | 開発 |
| C0001 | A 商事 | 000B | 藤本 | 32 | D02 | 人事 |
| C0001 | A 商事 | 001F | 三島 | 50 | D03 | 営業 |
| C0002 | B 科学 | 000A | 斉藤 | 47 | D03 | 営業 |
| C0002 | B 科学 | 009F | 田島 | 25 | D01 | 開発 |
| C0002 | B 科学 | 010A | 渋谷 | 33 | D04 | 総務 |

上記のテーブルに対して第二正規化を行う。
部分関数従属の関係にあるキー列 `{会社コード}` と従属列 `{会社名}` だけを別のテーブルに切り出す。
リレーションのためにキー列である `{会社コード}` は `社員` テーブルにも残している。

**`社員`テーブル**
| 会社コード | 社員 ID | 社員名 | 年齢 | 部署コード | 部署名 |
| ---------- | ------ | ------- | -------- | ---- | ---------- |
| C0001 | 000A | 中島 | 40 | D01 | 開発 |
| C0001 | 000B | 藤本 | 32 | D02 | 人事 |
| C0001 | 001F | 三島 | 50 | D03 | 営業 |
| C0002 | 000A | 斉藤 | 47 | D03 | 営業 |
| C0002 | 009F | 田島 | 25 | D01 | 開発 |
| C0002 | 010A | 渋谷 | 33 | D04 | 総務 |

**`会社`テーブル**
| 会社コード | 会社名 |
| ---------- | ------ |
| C0001 | A 商事 |
| C0002 | B 科学 |

これによって、`社員` テーブルも、新しく作成した `会社` テーブルも、全てのレコードが候補キーに完全関数従属している状態になった。

### 第 2 正規形でないと何が悪いのか？

**`社員`テーブル**
| 会社コード | 会社名 | 社員 ID | 社員名　 | 年齢 | 部署コード | 部署名 |
| ---------- | ------ | ------- | -------- | ---- | ---------- | ------ |
| C0001 | A 商事 | 000A | 中島 | 40 | D01 | 開発 |
| C0002 | B 科学 | 010A | 渋谷 | 33 | D04 | 総務 |

上記 `社員` テーブルに対し、社員情報は不明だが新たに `C銀行` という会社を追加したい。

| 会社コード | 会社名 | 社員 ID | 社員名　 | 年齢 | 部署コード | 部署名 |
| ---------- | ------ | ------- | -------- | ---- | ---------- | ------ |
| C0001      | A 商事 | 000A    | 中島     | 40   | D01        | 開発   |
| C0002      | B 科学 | 010A    | 渋谷     | 33   | D04        | 総務   |
| C0003      | C 銀行 |         |          |      |            |        |

しかし、これでは候補キーの一部である `社員ID` が `NULL` になる。
主キーの中に `NULL` のカラムが存在する状態は許可されていないため、上記のようにレコードを登録することはできない。

しかし、第 2 正規化によりテーブルを分割しておけば、会社情報のみを追加することが可能になる。

**`会社`テーブル**
| 会社コード | 会社名 |
| ---------- | ------ |
| C0001 | A 商事 |
| C0002 | B 科学 |
| C0003 | C 銀行 |

また、第 2 正規化をしなかった場合、下記のように同じ会社コードに対して異なる会社名が入ってきてしまう可能性があるが、第二正規化をすることでこのようなミスを防ぐことができる。

| 会社コード | 会社名 | 社員 ID | 社員名　 | 年齢 | 部署コード | 部署名 |
| ---------- | ------ | ------- | -------- | ---- | ---------- | ------ |
| C0001      | A 商事 | 000A    | 中島     | 40   | D01        | 開発   |
| C0001      | A 銀行 | 010A    | 渋谷     | 33   | D04        | 総務   |

## 第３正規形

下記テーブルに対し、第３正規化を行う。

**`社員`テーブル**
| 会社コード | 社員 ID | 社員名 | 年齢 | 部署コード | 部署名 |
| ---------- | ------ | ------- | -------- | ---- | ---------- |
| C0001 | 000A | 中島 | 40 | D01 | 開発 |
| C0001 | 000B | 藤本 | 32 | D02 | 人事 |
| C0001 | 001F | 三島 | 50 | D03 | 営業 |
| C0002 | 000A | 斉藤 | 47 | D03 | 営業 |
| C0002 | 009F | 田島 | 25 | D01 | 開発 |
| C0002 | 010A | 渋谷 | 33 | D04 | 総務 |

- 主キー（候補キー）: `{社員ID}`

**`会社`テーブル**
| 会社コード | 会社名 |
| ---------- | ------ |
| C0001 | A 商事 |
| C0002 | B 科学 |

- 主キー（候補キー）: `{会社コード}`

### 第３正規形の条件

- 主キー（候補キー）以外の列に関数従属している列が切り出された状態

### 第 3 正規化すべき条件

以下の 2 つ全ての条件を満たす場合、第 3 正規化をする必要がある。

1. 第 2 正規化された状態である
2. 主キー（候補キー）以外の列に関数従属している列が存在する

### 第３正規化を行う

第 2 正規化と同様にテーブルを分割する。

**`社員` テーブル**
| 会社コード | 社員 ID | 社員名 | 年齢 | 部署コード |
| ---------- | ------ | ------- | -------- | ---- |
| C0001 | 000A | 中島 | 40 | D01 |
| C0001 | 000B | 藤本 | 32 | D02 |
| C0001 | 001F | 三島 | 50 | D03 |
| C0002 | 000A | 斉藤 | 47 | D03 |
| C0002 | 009F | 田島 | 25 | D01 |
| C0002 | 010A | 渋谷 | 33 | D04 |

**`会社`テーブル**
| 会社コード | 会社名 |
| ---------- | ------ |
| C0001 | A 商事 |
| C0002 | B 科学 |
| C0003 | C 銀行 |

**`部署` テーブル**
| 部署コード | 部署 |
| ---- | ----|
| D01 | 開発 |
| D02 | 人事 |
| D03 | 営業 |
| D04 | 総務 |

このように、新たに部署を管理するための `部署` テーブルを独立させた。
これにより、全てののテーブルについて、非キー列はキー列に対してのみ従属するようになった。

## 正規化のまとめ

### 正規化とは更新時の不都合/不整合を排除するために行う

正規化の目的は

- データ登録・更新時の不都合を防ぐ
- データの冗長性を排除して、人間のオペレーションミスによるデータ不整合を防ぐ

### 正規化は従属性を見抜くことで可能になる

- 正規化を行うためには、テーブル内部の従属性の関係を見抜く必要がある
  - 部分関数従属が存在していれば第 2 正規化を行う
  - 推移的関数従属が存在していれば第３正規化を行う
- どの列がどのキーに従属しているかは、業務ロジック（ビジネスルール）で決まる
- 各列が業務上どのような意味と関係を持っているかを調べることが大事

### 正規化は常にすべきか？

- 第３正規化までは、原則として行う

### 正規化のメリット

- データの冗長性が排除され、更新時の不整合を防止できる
- テーブルの持つ意味が明確になり、開発者が理解しやすい

### 正規化のデメリット

- テーブルの数が増えるため、SQL 文で結合を多用することになり、パフォーマンスが悪化する
