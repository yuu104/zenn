---
title: "【アンチパターン】失われた事実"
---

## はじめに

RDB は「時間軸と直交するような設計」が大切である。
しかし、「時間軸と直交しないデータ = 履歴を保存すること」も重要。
履歴の保存を怠ると以下のようなケースに遭遇する。

- このデータがどのようにして今の値になったか不明
- ある日を境に売上データと商品マスタの単価データが合わない
- 払い戻しの処理が特別対応となる

具体的には以下のような状態が発生する。

1. 過去の事実（値）が失われる
2. 過去の事実（過程）が失われる
3. 集約によって詳細なデータが失われる

## 過去の事実（値）が失われる

エンティティが複数の属性を持つ場合、最新の状態だけを保存して、過去の状態や変更履歴を保持しない設計をしてしまうと、過去の値が失われる。
例えば、ユーザーの住所情報を更新する際に、過去の住所データを上書きしてしまうと、過去の住所がわからなくなり、「過去の事実（値）」が失われる。

問題点として、以下が挙げられる。

- いつ、どのようにデータが変わったかを後で追跡することができない
- 過去の状況に基づいた分析や法的な要件に対応できない

### 具体例: ユーザーの住所変更

ある e コマースシステムで、ユーザーがアカウントに住所を登録する。ユーザーは引っ越しするたびに住所を更新できるが、データベースでは以下のような単一の「住所」カラムだけが存在しているとする。

| ユーザー ID | 名前     | 住所               |
| ----------- | -------- | ------------------ |
| 1           | 田中太郎 | 東京都新宿区 1-1-1 |
| 2           | 鈴木花子 | 大阪市中央区 2-2-2 |

ユーザーが引っ越して新しい住所を更新すると、旧住所は上書きされて消える。たとえば、田中太郎さんが新宿区から渋谷区に引っ越した場合、データベースは以下のように更新される。

| ユーザー ID | 名前     | 住所               |
| ----------- | -------- | ------------------ |
| 1           | 田中太郎 | 東京都渋谷区 3-3-3 |
| 2           | 鈴木花子 | 大阪市中央区 2-2-2 |

この設計では、**過去の住所情報（新宿区 1-1-1）が失われ、いつどの住所に住んでいたかが追跡できない**という問題が発生する。

### 解決策: 履歴テーブルの導入

「住所履歴」を保存するためのテーブルを別に作り、ユーザーが住所を変更するたびに、その履歴を記録する仕組みにする。

1. **ユーザーテーブル**  
   | ユーザー ID | 名前 |
   | ---------- | -------- |
   | 1 | 田中太郎 |
   | 2 | 鈴木花子 |

2. **住所履歴テーブル**  
   | 履歴 ID | ユーザー ID | 住所 | 開始日 | 終了日 |
   | ------ | ---------- | ----------------- | -------------- | ---------------- |
   | 1 | 1 | 東京都新宿区 1-1-1 | 2022-01-01 | 2023-06-15 |
   | 2 | 1 | 東京都渋谷区 3-3-3 | 2023-06-15 | NULL |

これにより、ユーザーの住所が変更されるたびに過去の履歴を追跡でき、注文履歴などに対しても正確な住所が紐づけられるようになる。

## 過去の事実（過程）が失われる

状態変化が保存されない、つまり過程が失われるパターン。

例えば、「ステータス」というカラムに「作成」「承認」「発送」など異なるイベントを記録すると、過去にどのイベントが発生したかの履歴が消え、元の状態がわからなくなる。

### 具体例: ステータス管理

あるプロジェクト管理システムで、タスクの「ステータス」カラムがあり、以下のようにステータスを持たせている。

| タスク ID | タイトル    | ステータス |
| --------- | ----------- | ---------- |
| 1         | 仕様書作成  | 承認済み   |
| 2         | UI デザイン | 作成中     |

この設計では、ステータスが上書きされるたびに、過去のステータスが失われる。
例えば、「作成中」→「レビュー中」→「承認済み」という流れがあっても、最新の「承認済み」だけが記録され、どのタイミングでレビューが行われたのかがわからなる。

問題点として以下が挙げられる。

- プロジェクトの進行状況が正確に把握できない。特に、タスクがどの段階で滞っていたかなどの分析が不可能になる
- 過去のステータスが消失するため、後からプロジェクトの進行管理や改善に使えるデータが得られない

### 解決策: ステータス変更履歴の管理

ステータスの変更履歴を別テーブルに保存することで、過去のステータスの変遷を追跡できるようにする。

1. **タスクテーブル**  
   | タスク ID | タイトル |
   | -------- | ---------------- |
   | 1 | 仕様書作成 |
   | 2 | UI デザイン |

2. **ステータス履歴テーブル**  
   | 履歴 ID | タスク ID | ステータス | 変更日 |
   | ------ | -------- | ----------- | ---------------- |
   | 1 | 1 | 作成中 | 2023-01-01 |
   | 2 | 1 | レビュー中 | 2023-01-15 |
   | 3 | 1 | 承認済み | 2023-02-01 |

これにより、タスクがどのステータスを経て承認に至ったのかをすべて把握でき、後から詳細な分析も可能になる。

## 集約によるデータの消失

一部のデータを集約して保存することで、元の個々のデータが失われてしまうケース。
例えば、売上の月次集計だけを保存し、個々の取引データを削除すると、詳細な売上データ（商品ごとの売上など）が失われる。

### 具体例: 月次売上の集約

ある会社で、毎日の売上を集計して月次売上だけを保存し、詳細な日次データを削除してしまう設計。以下のような売上集計テーブルがあるとする。

| 月      | 売上合計     |
| ------- | ------------ |
| 2023-01 | 1,000,000 円 |
| 2023-02 | 1,200,000 円 |

この設計では、日次の売上データが削除されるため、**どの日にどの商品が売れたか**という詳細なデータが失われる。
例えば、1 月 10 日の売上が極端に高かった理由を調査したい場合、その詳細なデータがすでに消失しており、理由を分析することができない。

### 解決策: 原データを保持しつつ集計

日次の売上データを保持するテーブルを設け、必要に応じて月次や年次で集計する形にする。

1. **日次売上テーブル**  
   | 日付 | 商品 ID | 売上額 |
   | ---------- | ------ | ------- |
   | 2023-01-01 | 1 | 100,000 円 |
   | 2023-01-01 | 2 | 50,000 円 |
   | 2023-01-02 | 1 | 30,000 円 |

2. **月次売上集計テーブル**  
   | 月 | 売上合計 |
   | --------- | ---------- |
   | 2023-01 | 1,000,000 円 |
   | 2023-02 | 1,200,000 円 |

これにより、必要に応じて日次データに戻って詳細な分析が可能になる。
例えば、特定の日に何が売れたか、どの商品の売上が急増したかといった情報も追跡できる。

## トレードオフ

履歴を保存させる設計には以下のデメリットが存在する。

- レコードの保存量が増えるためテーブルサイズが増える
- 集計が単純な主キー検索でなくなるため。テーブルサイズが肥大化した際に検索速度が劣化する

:::details 集計が単純な主キー検索でなくなる

履歴を保存すると、同じエンティティ（例：ユーザー、商品、取引）に対して、複数の状態やデータ変更履歴が蓄積される。
これにより、**一意な主キーで 1 件だけの最新データを取得する**という単純な検索が難しくなる。

例えば、顧客の購入履歴を管理する場合、購入日時ごとに異なる税率や価格を保存する。
れにより、特定の顧客の最新の購入データを取得する際、以下のように「最新の 1 件だけを取得する」という操作が必要になる。

```sql
SELECT *
FROM purchase_history
WHERE customer_id = 1
ORDER BY purchase_date DESC
LIMIT 1;
```

これは単純な主キー検索（`SELECT * FROM table WHERE id = ?`）と比べ、複雑な条件付き検索になり、負荷が増す。

:::

## アンチパターンのチェックポイント

何がアンチパターンなのか？
それは、「**後からデータを遡りたいときに事実が失われている設計をしてしまう**」ということ。

アンチパターンに陥っていないか確認する際は以下をチェックする。

- 払い戻しなどの**取り消し処理に対応できるか**？
- 配送状況などの**ステータス変化を追えるか**？
- トラブル対応やデータ分析時、**欲しい情報が失われていないか**?

## すべてを履歴に残すべきか？

「トレードオフ」でも述べた通り、履歴の保存にはパフォーマンス劣化のデメリットが存在する。
そのため、無制限に履歴保存する訳ではなく、**ビジネス上重要なデータの変更履歴**に焦点を当てて保存することが重要。

しかし、RDB の責務内で履歴を持たせない場合は以下のような手段を取ると良い。

- 遅延レプリケーションを使用する
- アプリケーションログとして Elasticsearch などの分析ツールに保存する

:::details 遅延レプリケーション

「レプリケーション」とは、DB のデータを**複数のサーバー間でコピーし、同期する技術**。主にデータの可用性向上、負荷分散、バックアップ、データの整合性確保を目的として使用される。
複製元の DB を「マスター」と呼び、複製先の DB を「スレーブ」と呼ぶ。スレーブは読み取り専用として使用される。

「遅延レプリケーション」は、指定した時間分、スレーブに対してマスタからの複製を遅延させることができる。例えば、一日遅れのスレーブを作ったり 2 時間遅れのスレーブを作ったりできる。遅延レプリケーションは DB に柔軟な設計を与える。
主な目的としては以下がある。

- マスタで行われた誤った作業から保護する
- システムのデバッグ時の再現手法として使う

デメリットとしては以下がある。

- DB の複製のため、物理的なコストは高くなる
- バグなどでデータが壊れた際に遅延予定時間を超えると、戻せなくなる

:::
