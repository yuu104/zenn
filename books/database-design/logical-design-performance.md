---
title: "論理設計とパフォーマンス"
---

## 正規化のデメリット

- 正規化のメリットは、**データの整合性を保持できる**こと
- デメリットは、**正規化されたテーブル群に対する 検索 SQL が非常に遅くなり、パフォーマンスが劣化する**こと
- **SQL における結合は非常にコストの高い操作**
- 結合するテーブル数、及びレコード数が増えれば増えるほど処理時間が増す
- 正規化によるパフォーマンス劣化の原因の多くは、SQL の結合操作

## 正規化と SQL（検索）

### 結合（JOIN）とパフォーマンスの関係

以下の第３正規化されたテーブル群を例に考える。
![](https://storage.googleapis.com/zenn-user-upload/498287138710-20231021.png)

:::details 【ケース 1】社員名が「田島」の会社名を取得する
SQL で取得するステップは

1.  `社員` テーブルから `社員名` を検索条件として検索する
2.  検索にヒットした社員データの `会社コード` を使用して、`会社` テーブルから `会社名`　を検索条件として検索する

- `社員` テーブルと `会社` テーブルの２つのテーブルを検索対象とすることになる
- よって、SQL で 2 つのテーブルを結合する必要がある

```sql
SELECT 会社.会社名,
       社員.社員名
  FROM 社員 INNER JOIN 会社
              ON 社員.会社コード = 会社.会社コード
  WHERE 社員.社員名 = "田島";
```

```
会社名 社員名
----- -----
B科学  田島
```

:::

:::details 【ケース 2】会社名が「田島」の会社名と部署名を取得する

```sql
SELECT 会社.会社名,
       社員.社員名
       部署.部署名
  FROM 社員 INNER JOIN 会社
              ON 社員.会社コード = 会社.会社コード
            INNER JOIN 部署
              ON 社員.部署コード = 部署.部署コード
  WHERE 社員.社員名 = "田島";
```

```
会社名 社員名 部署名
----- ----- -----
B科学  田島   開発
```

:::

:::details 【ケース 3】会社ごとに何人いるかを集計する

```sql
SELECT 会社.会社コード,
       COUNT(社員.社員名) AS 社員数
       部署.部署名
  FROM 会社 LEFT OUTER JOIN 社員
              ON 社員.会社コード = 会社.会社コード
  GROUP BY 会社.会社コード;
```

```
会社コード 社員数
-------- -----
C0001    3
C0002    3
C0003    0
```

:::

どのケースも、データ取得のために**テーブルの結合（JOIN）** を行なっています。
\
正規化されたテーブルにおいて、単独のテーブルではすべてのデータをカバーして取得することができません。
これは、正規化が情報を複数のテーブルに分散させる行為だからです。
\
JOIN の特徴として、**結合回数が増えると指数関数的に負荷が大きくなります**。
JOIN は「掛け算」とも言われており、テーブルスキャンの場合、100 行と 100 行の JOIN では 10,000 行のテーブルスキャンになります。
10,000 行と 10,000 行では 100,000,000 行です...
\
このように、JOIN は SQl 処理の中で最も重い処理の一つと言えます。

:::message
**JOIN アルゴリズムの種類**

JOIN による結合アルゴリズムは複数存在します。（PostgreSQL の場合）

1. **Nested Loop Join（NLJ）**
   ![](https://storage.googleapis.com/zenn-user-upload/d1397060ae4d-20241027.png)
2. **Hash Join**
   ![](https://storage.googleapis.com/zenn-user-upload/adb73fa91085-20241027.png)
3. **Sort Merge Join**
   ![](https://storage.googleapis.com/zenn-user-upload/442732d03938-20241027.png)

| アルゴリズム    | 特徴                                                                                                                                                                                                                                                                                  |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| NLJ             | ・内部表の結合キーの列に利用できる INDEX がある場合、ループ数を省略できるため外部表が小さいほど高速になる<br>・内部表の結合キーが一意の場合は内部表対象レコードを絞りこめるため、より高速化できる<br>・1 レコードずつ確定するので、確定したレコードはレスポンスとして返すことができる |
| Hash Join       | ・「外部表が大きい場合、または内部表の対象件数が多い場合」と「結合条件の索引がなく、テーブルのフルスキャンが必要な場合」では NLJ より有利<br>・Hash 表を作成さえすれば結合は非常に高速だが、Hash 表の作成と保存ができるだけの十分なメモリが必要                                       |
| Sort Merge Join | ・ソートに用いる索引が作成されていると高速化できる<br>・Hash Join と同様に表の大部分を結合する場合に有効<br>・Hash Join と違い、等値結合だけでなく不等式（<, >, <=, >=）を使った結合にも利用できる<br>・INDEX が活用できる場合は Hash Join より速い場合もある                         |

:::

### 非正規化による解決

正規化を捨てれば、テーブル結合を行わずにデータを取得できる。

第 2 正規化する前の `社員` テーブル

| 会社コード | 会社名 | 社員 ID | 社員名　 | 年齢 | 部署コード | 部署名 |
| ---------- | ------ | ------- | -------- | ---- | ---------- | ------ |
| C0001      | A 商事 | 000A    | 中島     | 40   | D01        | 開発   |
| C0001      | A 商事 | 000B    | 藤本     | 32   | D02        | 人事   |
| C0001      | A 商事 | 001F    | 三島     | 50   | D03        | 営業   |
| C0002      | B 科学 | 000A    | 斉藤     | 47   | D03        | 営業   |
| C0002      | B 科学 | 009F    | 田島     | 25   | D01        | 開発   |
| C0002      | B 科学 | 010A    | 渋谷     | 33   | D04        | 総務   |

このテーブルを使用すれば、「田島さんの会社と部署名」を取得するにあたり、結合を使用せずに済む。

```sql
SELECT 会社名,
       社員名,
       部署名
  FROM 社員
 WHERE 社員名 = "田島"
```

正規化したテーブル群における SQL と比較すると、シンプルになっている。
また、テーブルの結合を行っていないため、パフォーマンスが良い。

## 正規化と SQL（更新）

:::message
**更新処理に関しては、正規化の方がパフォーマンスが良い。**
:::

会社名を更新する場合を考える。

### 正規化しない場合

第 2 正規化する前の `社員` テーブル

| 会社コード | 会社名 | 社員 ID | 社員名　 | 年齢 | 部署コード | 部署名 |
| ---------- | ------ | ------- | -------- | ---- | ---------- | ------ |
| C0001      | A 商事 | 000A    | 中島     | 40   | D01        | 開発   |
| C0001      | A 商事 | 000B    | 藤本     | 32   | D02        | 人事   |
| C0001      | A 商事 | 001F    | 三島     | 50   | D03        | 営業   |
| C0002      | B 科学 | 000A    | 斉藤     | 47   | D03        | 営業   |
| C0002      | B 科学 | 009F    | 田島     | 25   | D01        | 開発   |
| C0002      | B 科学 | 010A    | 渋谷     | 33   | D04        | 総務   |

上記テーブルの `会社名` を更新する。

```sql
UPDATE 社員
   SET 会社名 = "E物産"
 WHERE 会社コード = "C0001";
```

会社コードが `C0001` のレコードすべてに対し、更新処理を行う必要がある。

### 正規化した場合

**`会社`テーブル**
| 会社コード | 会社名 |
| ---------- | ------ |
| C0001 | A 商事 |
| C0002 | B 科学 |

```sql
UPDATE 会社
   SET 会社名 = "E物産"
 WHERE 会社コード = "C0001";
```

- 正規化した場合は、`社員` テーブルと `会社` テーブルに分かれている
- `会社名` を更新する場合、`会社` テーブルの１レコードに対して更新処理を行えばいい

## 正規化と非正規化、どちらが正解なのか？

正規化と検索 SQL のパフォーマンスは強い**トレードオフ**の関係。

![](https://storage.googleapis.com/zenn-user-upload/ca0be6f44d0e-20231021.png)

結局、どちらが正解なのか？

**原則として非正規化は許さない**

> 本節を次の論理的な意見で締めくくりたいと考えているが、それは今まで聞いたことがないものかもしれない。それは、「非正規化」はあくまでも最後の手段であるという姿勢でのぞむ、というものだ。要するに、十分に正規化された設計をあきらめてもよいのは、パフォーマンスを向上させるためのその他すべての戦略が要件を満たさない場合だけである。

:::message

- **非正規化は最後の手順**
- **最初は必ず正規化する**
- **非正規化以外でパフォーマンス向上が図れないかを検討する**

:::

## 非正規化とパフォーマンス

正規化による冗長性排除によって引き起こされる性能問題には以下の 2 パターンに分けられます。

- **サマリデータの冗長性排除**によるパターン
- **選択条件の冗長性排除**によるパターン

両者とも、1 対多の関連を持つ 2 つのテーブル間で発生します。

以下のテーブルを例に考える。

![](https://storage.googleapis.com/zenn-user-upload/356814a61924-20231022.png =300x)

### サマリデータの冗長性とパフォーマンス

受注日ごとに何個の商品が注文されているかを調べます。

- `受注日` 列は `受注` テーブルにある
- 商品の数は `受注明細` テーブルから数える必要がある
- このデータを取得するには、2 つのテーブルを結合した後に、`受注日` を `GROUP BY` により `受注日` に基づいて集計する

```sql
SELECT 受注.受注日,
       COUNT(*) AS 商品数
  FROM 受注 INNER JOIN 受注明細
               ON　受注.受注ID = 受注明細.受注ID
  GROUP BY 受注.受注日;
```

```
受注日      商品数
---------- ------
2012-01-05      14
2012-01-06      1
2012-01-07      5
2012-01-11      2
2012-01-12      1
```

この SQL は、`受注` と `受注明細` の 2 つのテーブルを結合している。
どちらのテーブルも、レコード数が多くなるため、この SQL は高コストな処理になり、パフォーマンスに問題を引き起こす。

#### 解決策

`受注` テーブルに対して新たなカラムを追加する。

![](https://storage.googleapis.com/zenn-user-upload/5bcec1b786ec-20231022.png)

`受注` テーブルに対して `商品数` の列が存在していれば、`受注明細` テーブルとの結合は必要ない。

```sql
SELECT DISTINCT 受注日, 商品数 FROM 受注;
```

```
受注日      商品数
---------- ------
2012-01-05      14
2012-01-06      1
2012-01-07      5
2012-01-11      2
2012-01-12      1
```

- `受注` テーブルに `商品` というサマリデータ（集計データ）を持つことは、冗長性を持たせた設計
- このような変更は非正規化になる
  - `{受注日}` -> `{商品数}` という関数従属がある
- 従って、**更新処理における問題が新たに発生するトレードオフとして検索処理のハイパフォーマンスがある**

:::message
**サマリデータを冗長に保持すると正規形に違反するが、検索を高速化できる**
:::

### 選択条件の冗長性とパフォーマンス

受注日が 2012-01-06 ~ 2012-01-07 の期間に注文された商品の一覧を出力します。

- 期間内に受けた注文は `受注ID` が `0003`, `0004`, `0005` の 3 つ
- 3 つの注文に含まれる商品は `商品明細` テーブルで取得できる
- よって、`受注` テーブルと `受注明細` テーブルを結合する必要がある

```sql
SELECT 受注.受注ID,
       受注明細.商品名
  FROM 受注 INNER JOIN 受注明細
               ON　受注.受注ID = 受注明細.受注ID
 WHERE 受注.受注日 BETWEEN "2012-01-06" AND "2012-01-07";
```

```
受注ID  商品名
------ ----------
0003   米
0004   アイロン
0004   ネクタイ
0005   チョコ詰め合わせ
0005   紅茶
0005   クッキーセット
```

この SQL は結合を必要とするため、コストが高いです。

#### 解決策

- 結合を防ぐために、`受注明細` テーブルに新たな `受注日` カラムを追加する

![](https://storage.googleapis.com/zenn-user-upload/553e791ad8dc-20231022.png)

これにより、`受注` テーブルを見る必要がなくなりました。

```sql
SELECT 受注ID,
       商品名
  FROM 受注明細
 WHERE 受注日 BETWEEN "2012-01-06" AND "2012-01-07";
```

```
受注ID  商品名
------ ----------
0003   米
0004   アイロン
0004   ネクタイ
0005   チョコ詰め合わせ
0005   紅茶
0005   クッキーセット
```

- カラムを一つ追加するだけで SQL から結合をなくすことができる
- ただ、このような変更は非正規化になる
  - `{受注ID}` -> `{受注日}` という関数従属がある

:::message
**選択条件を冗長に保持すると正規形に違反するが、検索を高速化できる。**
:::

## 非正規化による冗長性とパフォーマンスのトレードオフ

非正規化のリスクは

1. 検索のパフォーマンス向上の代償として、更新のパフォーマンスを低下させる
2. データのリアルタイム性（鮮度）を低下させる
3. 後続の工程で設計変更すると、手戻りが大きい

### ① 更新時のパフォーマンス

![](https://storage.googleapis.com/zenn-user-upload/5bcec1b786ec-20231022.png)

- テーブルにデータを追加する際に `商品数` を計算しておく必要がある
- また、注文内容の商品数が変わるたびに、`商品数` を更新する必要がある
- このような更新処理は頻繁に発生するため、考慮する必要がある

### ② データのリアルタイム性

- `受注明細` のデータを追加・更新した際、`受注` テーブルの `商品数` も更新する必要がある
- そのため、2 テーブル間のデータ整合性をとるための操作を行う必要がある
- データ同期の反映が短いほど、システムへかかる負荷は高くなり、性能問題も起きやすくなる

### ③ 改修コストの大きさ

- データモデルの変更はコードベースの修正に比べて改修コストが大きい
- これは、データのフォーマットがプログラムを決める DOA の大原則
- そのため、論理設計をする際は「システムの品質は（開発が成功するかどうかは）今ここで決まる！」という気概を持って臨む必要がある
- パフォーマンスを考える際は、ファイルやハードウェアといった物理層についても考慮せざるをえない
- 従って、**論理設計を適切に行うには、論理と物理のトレードオフを理解しておく必要がある**

## 正規形を保ちながらパフォーマンス改善する方法

パフォーマンス向上と正規形の保持はトレードオフです。
そのため、パフォーマンス向上のために無闇に非正規化を行うのは適切とは言えません。

非正規化を決断する前に、次のプラクティスで改善できないか検討しましょう。

### ① インデックスの最適化

- テーブルの結合時に適切にインデックスを付与することで、パフォーマンスを大幅に改善できる
- 結合や検索に使うカラムにインデックスを作成することで、結合クエリの処理が高速化される
  - 特に主キーや外部キーにインデックスを適用することで、結合処理の効率が飛躍的に向上
- ただし、インデックスが多すぎると更新処理に負担がかかるため、バランスを考慮して作成する必要がある

### ③ ビューとマテリアライズドビューの活用

- ビューを使用することで、複雑なクエリを簡単に再利用でき、クエリの書きやすさが向上する
- マテリアライズドビューを使用することで、結合結果を一時的に保存し、同じ結合クエリの実行頻度を減らしてパフォーマンスを向上させることができる
  - 特に、更新頻度が少なく、読み取りが多いデータに対して有効
  - ただし、データ更新時に再生成が必要であり、その更新コストに注意が必要

### ④ キャッシュテーブルの活用

- キャッシュテーブルは、頻繁に使用される結合結果や集計結果を別のテーブルに保存することで、クエリの実行時間を短縮する手法
- ビューやマテリアライズドビューと似たアプローチ
  - キャッシュテーブルはクエリの結果を保存するため、頻繁な再計算を避けることができる
  - 定期的な更新が必要になるが、読み取り専用のクエリに対して大幅なパフォーマンス改善が期待できる
