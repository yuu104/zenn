---
title: "論理設計とパフォーマンス"
---

## 正規化のデメリット

- 正規化のメリットは、**データの整合性を保持できる**こと
- デメリットは、**正規化されたテーブル群に対する 検索 SQL が非常に遅くなり、パフォーマンスが劣化する**こと
- **SQL における結合は非常にコストの高い操作**
- 結合するテーブル数、及びレコード数が増えれば増えるほど処理時間が増す
- 正規化によるパフォーマンス劣化の原因の多くは、SQL の結合操作

### 正規化と SQL（検索）

以下の第３正規化されたテーブル群を例に考える。
![](https://storage.googleapis.com/zenn-user-upload/498287138710-20231021.png)

#### 社員名が「田島」の会社名を取得する

SQL で取得するステップは

1. `社員` テーブルから `社員名` を検索条件として検索する
2. 検索にヒットした社員データの `会社コード` を使用して、`会社` テーブルから `会社名`　を検索条件として検索する

- `社員` テーブルと `会社` テーブルの２つのテーブルを検索対象とすることになる
- よって、SQL で 2 つのテーブルを結合する必要がある
  - 結合キーは `会社コード`

```sql
SELECT 会社.会社名,
       社員.社員名
  FROM 社員 INNER JOIN 会社
              ON 社員.会社コード = 会社.会社コード
  WHERE 社員.社員名 = "田島";
```

```
会社名 社員名
----- -----
B科学  田島
```

#### 会社名が「田島」の会社名と部署名を取得する

```sql
SELECT 会社.会社名,
       社員.社員名
       部署.部署名
  FROM 社員 INNER JOIN 会社
              ON 社員.会社コード = 会社.会社コード
            INNER JOIN 部署
              ON 社員.部署コード = 部署.部署コード
  WHERE 社員.社員名 = "田島";
```

```
会社名 社員名 部署名
----- ----- -----
B科学  田島   開発
```

#### 会社ごとに何人いるかを集計する

```sql
SELECT 会社.会社コード,
       COUNT(社員.社員名) AS 社員数
       部署.部署名
  FROM 会社 LEFT OUTER JOIN 社員
              ON 社員.会社コード = 会社.会社コード
  GROUP BY 会社.会社コード;
```

```
会社コード 社員数
-------- -----
C0001    3
C0002    3
C0003    0
```

- 正規化されたテーブルでは、単独のテーブルでは全てのデータをカバーして取得できない
- それは、正規化が情報を複数のテーブルに分散させる行為だから

#### 非正規化による解決

- 正規化を捨てれば、テーブル結合を行わずにデータを取得できる

第 2 正規化する前の `社員` テーブル

| 会社コード | 会社名 | 社員 ID | 社員名　 | 年齢 | 部署コード | 部署名 |
| ---------- | ------ | ------- | -------- | ---- | ---------- | ------ |
| C0001      | A 商事 | 000A    | 中島     | 40   | D01        | 開発   |
| C0001      | A 商事 | 000B    | 藤本     | 32   | D02        | 人事   |
| C0001      | A 商事 | 001F    | 三島     | 50   | D03        | 営業   |
| C0002      | B 科学 | 000A    | 斉藤     | 47   | D03        | 営業   |
| C0002      | B 科学 | 009F    | 田島     | 25   | D01        | 開発   |
| C0002      | B 科学 | 010A    | 渋谷     | 33   | D04        | 総務   |

このテーブルを使用すれば、「田島さんの会社と部署名」を取得するにあたり、結合を使用せずに済む。

```sql
SELECT 会社名,
       社員名,
       部署名
  FROM 社員
 WHERE 社員名 = "田島"
```

正規化したテーブル群における SQL と比較すると、シンプルになっている。
また、テーブルの結合を行っていないため、パフォーマンスが良い。

### 正規化と SQL（更新）

**更新処理に関しては、正規化の方がパフォーマンスが良い。**

会社名を更新する場合を考える。

#### 正規化しない場合

第 2 正規化する前の `社員` テーブル

| 会社コード | 会社名 | 社員 ID | 社員名　 | 年齢 | 部署コード | 部署名 |
| ---------- | ------ | ------- | -------- | ---- | ---------- | ------ |
| C0001      | A 商事 | 000A    | 中島     | 40   | D01        | 開発   |
| C0001      | A 商事 | 000B    | 藤本     | 32   | D02        | 人事   |
| C0001      | A 商事 | 001F    | 三島     | 50   | D03        | 営業   |
| C0002      | B 科学 | 000A    | 斉藤     | 47   | D03        | 営業   |
| C0002      | B 科学 | 009F    | 田島     | 25   | D01        | 開発   |
| C0002      | B 科学 | 010A    | 渋谷     | 33   | D04        | 総務   |

上記テーブルの `会社名` を更新する。

```sql
UPDATE 社員
   SET 会社名 = "E物産"
 WHERE 会社コード = "C0001";
```

会社コードが `C0001` のレコードすべてに対し、更新処理を行う必要がある。

#### 正規化した場合

**`会社`テーブル**
| 会社コード | 会社名 |
| ---------- | ------ |
| C0001 | A 商事 |
| C0002 | B 科学 |

```sql
UPDATE 会社
   SET 会社名 = "E物産"
 WHERE 会社コード = "C0001";
```

- 正規化した場合は、`社員` テーブルと `会社` テーブルに分かれている
- `会社名` を更新する場合、`会社` テーブルの１レコードに対して更新処理を行えばいい

### 正規化と非正規化、どちらが正解なのか？

- 正規化と検索 SQL のパフォーマンスは強い**トレードオフ**の関係

![](https://storage.googleapis.com/zenn-user-upload/ca0be6f44d0e-20231021.png)

#### 結局どっちなの？

- **原則として非正規化は許さない**

> 本節を次の論理的な意見で締めくくりたいと考えているが、それは今まで聞いたことがないものかもしれない。それは、「非正規化」はあくまでも最後の手段であるという姿勢でのぞむ、というものだ。要するに、十分に正規化された設計をあきらめてもよいのは、パフォーマンスを向上させるためのその他すべての戦略が要件を満たさない場合だけである。

- 非正規化は最後の手順
- 最初は必ず正規化する
- 非正規化以外でパフォーマンス向上が図れないかを検討する

## 非正規化とパフォーマンス

- 正規化による冗長性排除によって引き起こされる性能問題には以下の 2 パターンに分けられる
  - **サマリデータの冗長性排除**によるパターン
  - **選択条件の冗長性排除**によるパターン
- 両者とも、1 対多の関連を持つ 2 つのテーブル間で発生する

以下のテーブルを例に考える。

![](https://storage.googleapis.com/zenn-user-upload/356814a61924-20231022.png =300x)

### サマリデータの冗長性とパフォーマンス

#### 受注日ごとに何個の商品が注文されているかを調べる

- `受注日` 列は `受注` テーブルにある
- 商品の数は `受注明細` テーブルから数える必要がある
- このデータを取得するには、2 つのテーブルを結合した後に、`受注日` を `GROUP BY` により `受注日` に基づいて集計する

```sql
SELECT 受注.受注日,
       COUNT(*) AS 商品数
  FROM 受注 INNER JOIN 受注明細
               ON　受注.受注ID = 受注明細.受注ID
  GROUP BY 受注.受注日;
```

```
受注日      商品数
---------- ------
2012-01-05      7
2012-01-06      1
2012-01-07      5
2012-01-11      2
2012-01-12      1
```

この SQL は、`受注` と `受注明細` の 2 つのテーブルを結合している。
どちらのテーブルも、レコード数が多くなるため、この SQL は高コストな処理になり、パフォーマンスに問題を引き起こす。

#### 結合しない SQL を作るためのテーブル設計

`受注` テーブルに対して新たなカラムを追加する。

![](https://storage.googleapis.com/zenn-user-upload/5bcec1b786ec-20231022.png)

`受注` テーブルに対して `商品数` の列が存在していれば、`受注明細` テーブルとの結合は必要ない。

```sql
SELECT DISTINCT 受注日, 商品数 FROM 受注;
```

```
受注日      商品数
---------- ------
2012-01-05      7
2012-01-06      1
2012-01-07      5
2012-01-11      2
2012-01-12      1
```

- `受注` テーブルに `商品` というサマリデータ（集計データ）を持つことは、冗長性を持たせた設計
- このような変更は非正規化になる
  - `{受注日}` -> `{商品数}` という関数従属がある
- 従って、更新処理における問題が新たに発生するトレードオフとして検索処理のハイパフォーマンスがある

**サマリデータを冗長に保持すると正規形に違反するが、検索を高速化できる**

### 選択条件の冗長性とパフォーマンス

#### 受注日が 2012-01-06 ~ 2012-01-07 の期間に注文された商品の一覧を出力する

- 期間内に受けた注文は `受注ID` が `0003`, `0004`, `0005` の 3 つ
- 3 つの注文に含まれる商品は `商品明細` テーブルで取得できる
- よって、`受注` テーブルと `受注明細` テーブルを結合する必要がある

```sql
SELECT 受注.受注ID,
       受注明細.商品名
  FROM 受注 INNER JOIN 受注明細
               ON　受注.受注ID = 受注明細.受注ID
 WHERE 受注.受注日 BETWEEN "2012-01-06" AND "2012-01-07";
```

```
受注ID  商品名
------ ----------
0003   米
0004   アイロン
0004   ネクタイ
0005   チョコ詰め合わせ
0005   紅茶
0005   クッキーセット
```

#### 選択条件が冗長でないことの問題点

- この SQL は結合を必要とするため、コストが高い
- 結合を防ぐために、`受注明細` テーブルに新たな `受注日` カラムを追加する

![](https://storage.googleapis.com/zenn-user-upload/553e791ad8dc-20231022.png)

- これにより、`受注` テーブルを見る必要がなくなった

```sql
SELECT 受注ID,
       商品名
  FROM 受注明細
 WHERE 受注日 BETWEEN "2012-01-06" AND "2012-01-07";
```

```
受注ID  商品名
------ ----------
0003   米
0004   アイロン
0004   ネクタイ
0005   チョコ詰め合わせ
0005   紅茶
0005   クッキーセット
```

- カラムを一つ追加するだけで SQL から結合をなくすことができる
- ただ、このような変更は非正規化になる
  - `{受注ID}` -> `{受注日}` という関数従属がある

**選択条件を冗長に保持すると正規形に違反するが、検索を高速化できる。**

## 冗長性とパフォーマンスのトレードオフ

非正規化のリスクは

1. 検索のパフォーマンス向上の代償として、更新のパフォーマンスを低下させる
2. データのリアルタイム性（鮮度）を低下させる
3. 後続の工程で設計変更すると、手戻りが大きい

### 更新時のパフォーマンス

![](https://storage.googleapis.com/zenn-user-upload/5bcec1b786ec-20231022.png)

- `商品数` というサマリデータを追加した `受注` テーブルの場合
- テーブルにデータを追加する際に商品数を計算しておく必要がある
- また、注文内容の商品数が変わるたびに、`商品数` を更新する必要がある
- このような更新処理は頻繁に発生するため、考慮する必要がある

### データのリアルタイム性

- `受注明細` のデータを追加・更新した際、`受注` テーブルの `商品数` も更新する必要がある
- そのため、2 テーブル間のデータ整合性をとるための操作を行う必要がある
- データ同期の反映が短いほど、システムへかかる負荷は高くなり、性能問題も起きやすくなる

### 改修コストの大きさ

- データモデルの変更はコードベースの修正に比べて改修コストが大きい
- これは、データのフォーマットがプログラムを決める DOA の大原則
- そのため、論理設計をする際は「システムの品質は（開発が成功するかどうかは）今ここで決まる！」という気概を持って臨む必要がある
- パフォーマンスを考える際は、ファイルやハードウェアといった物理層についても考慮せざるをえない
- 従って、**論理設計を適切に行うには、論理と物理のトレードオフを理解しておく必要がある**
