---
title: "インデックス"
---

- データの高速検索とアクセスを可能にするデータ構造の一つ
- データベース内のテーブルやビューの特定の列に対して、効率的なデータの格納方法と検索方法を提供する

:::message
インデックスを理解するには、ちょうど本の索引をイメージすると良いでしょう。特定の単語がどのページに存在するか見つけ出したいとき、1 ページ目から順にページをめくっていくのは、ページ数が多くなればなるほど非効率で時間がかかります。本の索引は、この手間を省略して、ある単語が何ページ目に書かれているかをダイレクトに示してくれるので、直接該当ページへ飛ぶことを可能にします。
:::

https://it-biz.online/it-skills/index/

- SQL のチューニング手段としてポピュラー
- プログラミング言語的な表現をすると、（x, α）という形式の配列
  - `x` はキー値（列の値）
  - `α` はそれに結びつく情報（実データ or ポインタ）
  - `α` はポインタであることが多い
- インデックスは、「DBMS 内にテーブルとは独立に保持されるオブジェクト」

![](https://storage.googleapis.com/zenn-user-upload/2515277426e3-20231022.png)

## インデックスの何が良いの？

インデックスが SQL のパフォーマンス改善においてポピュラーな理由は、

1. アプリケーションのコードに影響を与えない（アプリケーション透過的）
2. テーブルのデータに影響を与えない（データ透過的）
3. それでいて性能改善の効果が大きい

### アプリケーション透過的

- インデックスを使用するかどうかは、DBMS が自動的に判断する
- そのため、インデックスを使う場合、単純にデータベース側にインデックスを作成すればいい
- アプいケーションプログラムの変更が必要ない
- よって、インデックスを使う際のハードルが非常に低い
- 非正規化と比べても導入しやすい・負債になりにくい

### データ透過的

- インデックスを作成してもテーブル内のデータには影響しない
- インデックスを作成する際に論理設計に影響を及ぼすことはない

### 大きな性能改善効果

- インデックスのもたらす性能改善の効果は劇的
- インデックスの性能が、データ量に対して線形よりも緩くしか劣化しない
- デメリットよりもメリットが大きく上回る

## B-tree インデックスの長所

- B-tree インデックスのパフォーマンスが非常に優れているわけではない
- 場合によっては他のタイプのインデックスが優れていることもある
- B-tree インデックスの長所は**平均点の高さ**

![](https://storage.googleapis.com/zenn-user-upload/0c4142834816-20231022.png)

1. **均一性**
   各キー値の間で検索速度にバラツキが少ない。
2. **持続性**
   データ量の増加に比してパフォーマンス低下が少ない。
3. **処理汎用性**
   検索、挿入、更新、削除のいずれの処理もそこそこ速い。
4. **非等値性**
   符号（=）に限らず、不等号（<、>、<=、>=）を使ってもそこそこ速い。
5. **親ソート性**
   GROUP BY、ORDER BY、COUNT/MAX/MIN などなどソートが必要な処理を高速化できる。

## B-tree インデックスの構造

![](https://storage.googleapis.com/zenn-user-upload/c11a97e74650-20231022.png)

- B-tree は、「木」という名前の通り、木構造でデータを保持する
- リーフノードだけが実データに対するポインタを保持する
- データベースは、最上位のノードから順にノードをたどって、リーフから実データを見つける

### 均一性

- B-tree はなぜ均一性が良いのか？
- それは、**平衡木（balancedtree）** であるため
- 平衡木とは、どのリーフもルートからのよりが一定である木のこと
- どのキー値を使用しても、常にリーフまでの距離が一定になる
- よって、探索を同じ計算量で行える

![](https://storage.googleapis.com/zenn-user-upload/8056d9f67f76-20231022.png)

- B-tree は、最初は平衡木だが、テーブルへの挿入、更新、削除などが繰り返されることでインデックスの構造も崩れ、非平衡木になることがある...
- 木のバランスを自動で修正する機能も備わっているが、長時間の運用になればバランスが悪くなる...

### 持続性

- Btree といえども、長期的には性能劣化が発生する
- しかし、劣化は非常に緩やか
- テーブルのデータ量が増えても、B-tree の検索や更新にかかる時間はほとんど増えない
- 厳密には、データ量の対数に比例して増える
- これは、テーブルをフルスキャンするよりもかなり高速

![](https://storage.googleapis.com/zenn-user-upload/5793d3413fc6-20231022.png)

- B-tree インデックスの性能劣化が緩やかなのは何故か？
- それは、B-tree がかなり「平べったい」木だから
- 木の高さは平均的には 3~4 程度
- 背が低い木であることは、データ量が増えても変わらない

### 処理汎用性

- B-tree インデックスは、挿入、更新、削除、検索のコストは O(log n)
- いずれの処理も同じくらいの探索速度となる

### 非等値性

- Btree は、等号（=）による検索のみならず、不等号（<、>、<=、>=）や BETWEEN といった範囲検索の条件に対しても、高速化を可能とする
- **B-tree は、構築されるとき必ずキー値をソートする**
- よって、リーフノードを一つに絞れなくても、特定のノードよりも「左」や「右」のノードだけに探索範囲を絞ることが可能
- Btree が効果を持たない検索条件は、否定条件（<>、!=）

### 親ソート性

- SQL は一切の手続きを記述しないため、SELECT 文や UPDATE 文の中でも明示的にソートを記述しない
- しかし、以下のような処理を記述したときには、暗黙に DBMS 内部でソートが行われる
  - 集約関数（COUNT、SUM、AVG、MAX、MIN）
  - ORDERBY 句
  - 集合演算（UNION、INTERSECT、EXCEPT）
  - OLAP 関数（RANK、ROW_NUMBER など）
- ソートというのは、かなりコストの高い演算
- ソートは DBMS 内部で専用のメモリ領域が割り当てられており、その内部に一時的にデータを保持して実施される
- 大量のデータのソートが必要な場合、メモリに載りきらないために溢れてしまうことがある
- その場合、一時的にディスクへデータを書き出す
- このときの I/O コストが非常に大きなものになる
- したがって、SQL 文を記述する際は、極力大きなソートを避けることがパフォーマンス上は望ましい

::: details メモリとディスク

- **メモリ（RAM）**
  - メモリは高速アクセス可能な一時的なデータ保存領域
  - DB サーバがメモリ内に持つデータは、クエリの実行に高速でアクセス可能
  - メモリは DB サーバの性能向上に寄与する
  - DB がメモリ内でクエリを処理できる場合、DB の応答時間が短縮され、パフォーマンスが向上する
  - メモリ内にデータを保持できる限り、I/O 操作（ディスクアクセス）が発生せず、高速なデータ処理が可能
  - この状態を「メモリ内での処理」と呼ぶ
- **ディスク**

  - ディスクは永続的なデータ保存領域で、DB の永続的なストレージとして使用される
  - DB がディスクに格納されたデータを読み取るために I/O 操作が必要
  - ディスクアクセスはメモリアクセスに比べて遅いため、DB がディスクからデータを読み込む際にはコストがかかる
  - 特に、ディスク I/O はデータベースのボトルネックとなることがある
  - ソートや集約操作のようなクエリが大量のデータをディスクにアクセスさせる場合、ディスク I/O のコストが増加し、パフォーマンスが低下する

:::

- **B-tree は、構築されるとき必ずキー値をソートして保持する**
- そのため、B-tree インデックスが存在する列を ORDER BY 句のキーとして指定した場合、上述のソート処理をスキップすることが可能になる

## B-tree インデックスの設計方針

### インデックスはどの列に作れば良いか？

以下の指針で作成する。

1. 大規模なテーブルに対して作成する
2. カーディナリティの高い列に作成する
3. SQL 文で WHERE 句の選択条件、または結合条件に使用されている列に作成する

### B-tree インデックスとテーブルの規模

![](https://storage.googleapis.com/zenn-user-upload/21908feb552c-20231022.png)

- データ量が少ない場合、B-tree インデックスを使うよりもフルスキャンに任せた方が高速な場合がある
- しかし、この場合も処理時間の差はごくわずか
- つまり、**データ量が少ない場合はインデックスの効果がない**
- では「データ量が少ない」の閾値はどの程度なのか？
- ストレージやサーバの性能など環境要因によって変わる
- 大体の目安はレコード数が 1 万件以下

### B-tree インデックスとカーディナリティ

- インデックスを作成する列として適不適を判断するための重要な情報が**カーディナリティ**
- 特定の列の値が、どのぐらいの種類の多さを持つか、ということを表わす概念
- 例として、「性別」を表す列を考える
  - この列が持つ値としては「男性」「女性」「不詳」
  - よって、この列のカーディナリティは「3」
  - これは、カーディナリティが小さい例
- 「顧客の口座番号」や「受付日」のカーディナリティは多数ある
- **B-tree インデックスを作る際は、カーディナリティの高い列を選ぶことが基本**
- 目安は、特定のキー値を指定したときに、全体のレコード数の 10%以下に絞り込める場合にインデックスを貼る

#### カーディナリティの注意点

::: details 複合列に対してインデックスを作成する場合、カーディナリティは対象の複合列の組み合わせで考える

たとえば、（a,b,c）という列にインデックスを作成するとして、カーディナリティがそれぞれ a は 2、b は 10、C は 5 だとします。
この場合、どの一列をとっても、絞り込みの率は 5％より大きくなります。
しかし、(a,b,c)という組み合わせで見た場合のカーディナリティが 100 だとすれば、絞り込みの率は 1％となり、Btree インデックスは十分に有効性を発揮します（なお、なるべく先頭に近いキー、たとえば a や b のカーディナリティが高いほど、効率的に絞り込めるため性能的に有利です）。

:::

::: details カーディナリティが高くても、特定の値にデータが集中しているような列は向いていない

たとえば、1 ～ 100 までの値を取る列があったとします。
この列のカーディナリティは 100 です。
ところが、値の 99％が 100 で、1 ～ 99 の値は全体の 1％しか取らない、というようなケースでは Btree による検索性能は安定しません。
これは、100 を指定した SELECT 文が非常に広範囲の検索を行なわなければならないのに対して、残りの 1 ～ 99 の値を指定したときはほぼピンポイントでヒットするからです。

:::

総括すると、
**カーディナリティが高い列ほどインデックスの効果が高い。
ただし、値が平均的に分散しているのがベスト。**

## B-tree インデックスの恩恵を受けないパターン

SQL で検索条件や結合条件として使用されない列にインデックスを作っても無駄。
`SomeTable` テーブルの `col_1` カラムにインデックスが存在する例を考える。
以下の SQL は全てインデックスを利用できていない。

### インデックス列に演算を行っている

```sql
SELECT *
  FROM SomeTable
 WHERE col_1*1.1 > 100;
```

- B-tree の中で保持されているデータは、`col_1` であり、`col_1*1.1` ではない
- そのため、上記 SQL はインデックスを作成した恩恵を受けることができない
- インデックスの恩恵を受けるためには、以下のように変更する

```sql
SELECT *
  FROM SomeTable
 WHERE col_1 > 100/1.1;
```

### 牽引列に対して SQL 関数を適用している

```sql
SELECT *
  FROM SomeTable
 WHERE SUBSTR(col_1, 1, 1)='a';
```

- `SUBSTR()` は文字列から一部を抽出する
  - `SUBSTR(文字列, 切り取り開始位置, 長さ)`
- インデックスの中に存在する値は `col_1`　であり、`SUBSTR(col_1, 1, 1)` ではない

### IS NULL 述語を使っている

```sql
SELECT * 
  FROM SomeTable 
 WHERE col_1 IS NULL;
```

- B-tree は NULL をデータ値として保持していない
- `IS NULL` `IS NOT NULL` に対しては有効ではない
- DBMS によっては、有効な場合もある
- しかし、汎用性はない

### 否定形を用いている

```sql
SELECT *
  FROM SomeTable
 WHERE col_1 <> 100;
```

- 否定形はインデックスを利用できない
- たとえ利用したとしても検索範囲が広すぎて役に立たない

### OR を用いている

```sql
SELECT *
  FROM SomeTable
 WHERE col_1 = 99 OR col_1 100;
```

- OR を用いた場合はインデックスが利用されない
- 以下のように、`IN` で書き換えて回避する

```sql
SELECT *
  FROM SomeTable
 WHERE col_1 IN(99, 100);
```

### 後方一致、中間一致の LIKE 述語を用いている

```sql
SELECT * FROM SomeTable WHERE col_1 LIKE '%a';
```

```sql
SELECT * FROM SomeTable WHERE col_1 LIKE '%a%;
```

- `LIKE` を使うときは、前方一致検索だけがインデックスの恩恵を受ける

```sql
SELECT * FROM SomeTable WHERE col_1 LIKE 'a%;
```

### 暗黙の型変換を行なっている

`col_1` が文字列の場合

```sql
SELECT * FROM SomeTable WHERE col_1 = 10;
```

上記のように、データ型の異なる列値を SQL において選択条件・結合条件として利用した場合はインデックスの恩恵を受けない。
以下のように**明示的**に型変換する必要がある。

```sql
SELECT * FROM SomeTable WHERE col_1 = '10';
```

```sql
SELECT * FROM SomeTable WHERE col_1 = CAST(10, AS CHAR(2));
```

## 主キー及び一意制約の列は作成不要

- DBMS は主キーや一意制約に対して、内部で自動的にインデックスを作成する
- そのため、二重でインデックスを作成する必要はない

## 更新性能を劣化させる

- インデックスは（一般的に）テーブルとは独立のオブジェクトとして DBMS 内部に保持されている
- インデックスが作成されている対象の列値が変更すると、インデックス内に保持している値も変更する必要がある
- よって、インデックスを作成するほど、テーブルに対する更新性能が劣化する
- トレードオフに注意して、無駄なインデックスの作成を防ぐ必要がある

## 定期的なメンテナンスを行う

- インデックスは、テーブルのデータが更新されるにつれ、長期的には構造が崩れて劣化する
- インデックスの再構築を行うことが、性能維持にとって大切

## 他のインデックスアルゴリズム

### B+tree

https://mond.how/ja/topics/sv7z7ljlcyjax3q/otzqmzpvmse5oip

## その他参考リンク

https://zenn.dev/calloc134/articles/4f96b0fe093489#b-tree(b%2Btree)-%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF
