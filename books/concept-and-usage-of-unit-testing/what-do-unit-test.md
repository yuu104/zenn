---
title: "なぜ単体テストを行うのか？"
---

## 単体テストの現状

- 近年、単体テストはソフトウェア業界に広く浸透した
- 単体テストを導入することは当然の認識になった
- プロダクションコードとテストコードの割合は 1:1 ~1:3（場合によっては 1:10 になることも）
- 「単体テストを書くべきか？」から「良い単体テストを書くとはどういうことか？」へ
- 自動化されたテストをいくら用意しても、望ましい結果を得られるとは限らない
- リグレッションテストに失敗し、新たなバグが何度も出現することも多い
- プロジェクトの助けになることを目的に導入した単体テストが、返って悪化させることも良くある
- 「良い単体テスト」が書けるかどうかがプロジェクトの成功に大きく左右する
- よって、「良いテストとは何か？」を探求することは重要
- しかし、「良いテスト」について議論されることは少ない

## なぜ単体テストを行うのか？

### ソフトウェアの成長を持続可能なものにするため

単体テストの目的は「**ソフトウェアの成長を持続可能なものにするため**」です。

ソフトウェアというものは、簡単に肥大化します。
しかし、その成長を持続させることは簡単ではありません。

初期フェーズでは短い時間で素早く順調に成長していきます。
足枷となるもの（複雑化したコード、適さなくなったアーキテクチャ、etc.）が何もないからです。

しかし、時間の経過につれ、同じ成長をするために必要な労力が大きくなります。
これにより、当初あった開発スピードは失われ、最終的には何をしても成長できなくなる場合もあります。

![](https://storage.googleapis.com/zenn-user-upload/70d10ab58633-20241123.png =450x)
_ソフトウェアの成長曲線（自動テストがない場合）_

なぜ開発スピードが落ちるのでしょうか？
それは、**コードの劣化によるエントロピー（無秩序の量）が多くなるから**です。

コードに対して何らかの変更を加えることは、エントロピーを増やすことを意味します。
そして、無秩序な状態を放置しておくと、ソフトウェアはすぐさま複雑になります。
そうなると、次のような苦しい経験をする羽目になります。

- 簡単な機能追加・修正に時間がかかる
- 変更による影響範囲が特定できない
- 変更により、良くわからない新たなバグが生まれる
- 既存コードが理解できない
- 実装タスクを完遂させるまでの見積もりが困難になる

エンジニアであれば、一度は経験したことがあるのではないでしょうか？
「無秩序により開発スピードが落ちる」というのはこういうことです。

### 単体テストにより、無秩序から脱却する

エントロピー（無秩序の量）の増大により、成長の持続可能性が失われることを説明しました。
開発者を苦しめ、ソフトウェアの成長を著しく妨げる「無秩序」はどのように解消すれば良いのでしょうか？

この解決策として有効なものが、自動テストです。
そして、その手法の 1 つとして存在するのが単体テストなのです。

単体テストの導入により生まれる以下の恩恵が、無秩序の解消に繋がります。

1. **コードの信頼性をすぐに確認できる**
   コードに変更を加えた際、その変更が既存のロジックに悪影響を及ぼしていないことを素早く確認できます。
   自動で実行される単体テストによりコードの動作が期待通りであることがすぐに検証でき、変更が原因でエラーが発生していないかを早期に発見できます。
   この即時的なフィードバックが、無秩序の増大を防ぐ大きな力となります。
2. **リファクタリングしやすくなる**
   リファクタリングは、無秩序なコードを改善するための有効な手段です。
   しかし「銀の弾丸」というわけではなく、相応のリスクもあります。これまで正常に動いていたコードを変更するので、返ってバグを生み出してしまう可能性があります。
   そのため、開発者がリファクタリングを行う際には、既存の動作が壊れる不安と戦うことになり、その不安がリファクタリングの機会を妨げてしまうのです。
   単体テストが整備されていれば、リファクタリング後の挙動をテストで確認できるため、開発者は躊躇なく既存コードを変更し、改善を進めることができます。
3. **開発者が自分の書いたコードに対し、根拠ある自信を持つことができる**
   「コードの信頼性をすぐに確認できる」と「リファクタリングしやすくなる」は開発者に自信を与えることが出来ます。
   \
   まず、単体テストによる即時的なフィードバックが、開発者にとって大きな精神的な支えとなります。
   自分が加えた変更が既存の機能に影響を与えていないかを迅速に確認できるため、「間違っていたらすぐに教えてくれる」環境が整い、開発者は安心して新しい機能追加や変更を進めることができます。
   この安心感が、開発者に「自分のコードは期待通りに動作している」という根拠ある自信をもたらします。
   \
   また、この安心感はリファクタリングの促進に繋がります。
   改善の機会が増えれば無秩序なコードベースは次第に秩序あるものに変化し、それを維持し続けることが可能になります。
   これにより、開発者は「良いコードが書けている」という自信と、コードに対する誇りを持つことができます。

単体テストにより開発者が自信を持つことができる環境が整えば、より積極的にコードの改善や新規アイデアの導入に挑戦することができ、成長の加速へ繋がります。
このサイクルを維持することで持続可能なソフトウェアの成長が実現可能になります。

![](https://storage.googleapis.com/zenn-user-upload/c909bab5850b-20241123.png =450x)
_ソフトウェアの成長曲線（自動テストがある場合）_

### 単体テストの導入には労力がかかる

単体テストの欠点は、導入コストです。
特に既存プロジェクトに対してテストを導入することは、大きな労力が必要になるかもしれません。

初期フェーズではテストがない方が開発コストを削減でき、成長速度も勝るでしょう。
しかし、中長期でみると優位性は逆転し、その差は圧倒的なものになります。
![](https://storage.googleapis.com/zenn-user-upload/c7b9727ba886-20241124.png =450x)

### 「より優れた設計に改善するため」ではない

単体テストを必ず書くようにすれば、設計はより優れたものになります。
しかし、単体テストによって到達したい第一目標ではありません。
単体テストにより設計が改善されることは、副産物にすぎません。

:::message
**単体テストと設計の関係**

「単体テストのしやすさ」から「プロダクションコードの質」を以下のように評価することができます。

![](https://storage.googleapis.com/zenn-user-upload/188d9f90bb2a-20241124.png =450x)

単体テストがしにくい理由は、コードが密結合になっているからです。
\
つまり、以下の関係性が成り立つのです。

![](https://storage.googleapis.com/zenn-user-upload/0f98ad2a338b-20241124.png)

\
一方、以下のように評価することはできません。

![](https://storage.googleapis.com/zenn-user-upload/7ec70cb16d4c-20241124.png =450x)

\
単体テストがしやすいということは、コードが疎結合になっていることを示唆します。
しかし、疎結合であれば、プロダクションコードの質が高く良い設計になっているとは限らないのです。

![](https://storage.googleapis.com/zenn-user-upload/a994abdcd20c-20241124.png)

:::

### 質の低いテストは意味がない

単体テストの導入がソフトウェアの成長維持に繋がるということお話しました。
しかし、ただ単に導入すれば良くなるというわけではありません。
作成されたテストの質が重要です。

テストの質が低い場合でも、初期フェーズではエントロピーの増加を遅らせることが可能です。
しかし、時間経過に伴い、開発コストはテストが存在しない場合と比較して大差ない状態となります。

そのため、長期的には「テストがないソフトウェア」と「質の低いテストがあるソフトウェア」の成長速度は変わりません。

![](https://storage.googleapis.com/zenn-user-upload/0a9517af61d8-20241124.png =450x)

なぜ質の低いテストは、ソフトウェアの成長速度を落とすのでしょうか？
それは、以下のような事象が発生し、「無秩序」を生み出してしまうからです。

- テストが間違った理由で失敗することが頻繁に発生する
- 変更による意図しないバグを検出できない
- テストの運用コストが増大する

:::message

**テストの運用コストとは？**
テストの導入にあたり、様々な作業が必要になります。

- プロダクションコードのリファクタリングに伴い、テストコードをリファクタリングする
- プロダクションコードを変更するたびにテストを実施する
- テストが間違って失敗した際の対処
- プロダクションコードの振る舞いを理解するために、テストコードを読む

:::

では、なぜ質の低いテストが生まれるのでしょうか？
それは、**単体テストがどのようにプロジェクトの助けとなるかを理解できていない**からです。
単体テストによる恩恵を理解できていない場合、「単体テストを書く」こと自体が目的となってしまいがちです。

そのため、「ソフトウェアの成長を助けるテストだけを作る」ことに意識を向け、そのために良いテストについて学ぶことが重要なのです。

## カバレッジとテストの質

ソフトウェアの持続的な成長には質の高いテストが必要です。

では、テストの質はどのように評価するのでしょうか？
評価指標の一つとして、カバレッジ（網羅率）があります。

### カバレッジ（網羅率）とは？

カバレッジとは「**どれだけのプロダクションコードがテストによって実行されたか？**」を示す指標です。
カバレッジを計測することで、不足しているテストを発見することができます。

カバレッジには様々な種類があり、テストの質を評価する際に良く利用されます。
代表的なカバレッジとして、**コードカバレッジ**と**ブランチカバレッジ**があります。

### コードカバレッジ(コード網羅率)

カバレッジの中で最も利用されるものであり、**テストカバレジ**とも呼ばれます。

![](https://storage.googleapis.com/zenn-user-upload/c5912cad459b-20241130.png =550x)

\
以下の例を見てみます。

```ts
// プロダクションコード
function isStringLong(input: string): boolean {
  if (input.length > 5) {
    return true; // このテスト・コードからは実行されない
  }
  return false; // テストの際に実行される
}

// テストコード
test("should return false for short strings", () => {
  const result = isStringLong("abc");
  expect(result).toBe(false); // このテストでは input.length <= 5 の場合をテストしている
});
```

プロダクションコード（`isStringLong` メソッド）の総行数は `6` です。
そして、テストコードによって実行されるプロダクションコードの行数は `5` （`return true` を除いた）です。
条件分岐の内、片方（`false` となる場合）しかテストできていませんね。
従って、コードカバレッジは `5/6 = 0.83 = 83%` となります。

:::details java

```java
// プロダクションコード
public class IsStringLong {
    public static boolean isStringLong(String input) {
        if (input.length() > 5) {
            return true; // このテスト・コードからは実行されない
        }
        return false; // テストの際に実行される
    }
}

// テストコード
public class IsStringLongTest {

    @Test
    public void testIsStringLong() {
        boolean result = IsStringLong.isStringLong("abc");
        assertEquals(false, result); // このテストでは input.length <= 5 の場合をテストしている
    }
}
```

プロダクションコード（`isStringLong` メソッド）の総行数は `6` です。
そして、テストコードによって実行されるプロダクションコードの行数は `5` （`return true` を除いた）です。
従って、コードカバレッジは `5/6 = 0.83 = 83%` となります。

:::

\
では、この関数をリファクタリングするとどうなるのでしょうか？

```ts
function isStringLong(input: string): boolean {
  return input.length > 5;
}
```

:::details Java

```java
public class IsStringLong {
    public static boolean isStringLong(String input) {
        return input.length() > 5;
    }
}
```

:::

先程のテストを実行すると、プロダクションコードの総行数（3 行）はすべて実行されます。
よって、コードカバレッジは 100%になります。

:::message
コードカバレッジは 83% → 100% に向上していますが、**テストの質は向上していません。**

なぜなら、検証している内容は変化していないからです。
数値は向上していますが、「片方の条件（`false` となる場合）しか検証していない」という事実は変わりません。
:::

### ブランチカバレッジ（分岐網羅率）

コードの行数ではなく、**分岐（if 文や switch 文など）** に着目したカバレッジです。

![](https://storage.googleapis.com/zenn-user-upload/f4aa66b41acc-20241130.png =550x)

\
先程の例で見てみましょう。

```ts
// プロダクションコード
function isStringLong(input: string): boolean {
  if (input.length > 5) {
    return true; // このテスト・コードからは実行されない
  }
  return false; // テストの際に実行される
}

// テストコード
test("should return false for short strings", () => {
  const result = isStringLong("abc");
  expect(result).toBe(false); // このテストでは input.length <= 5 の場合をテストしている
});
```

`isStringLong` は分岐経路が 2 つ存在しています。
そして、テストでは `false` となる場合の 1 経路しか実行していません。
従って、カバレッジは `1/2 = 0.5 = 50%` となります。

リファクタリングをした場合はどうでしょうか？

```ts
function isStringLong(input: string): boolean {
  return input.length > 5;
}
```

この場合も、テストでは `false` となる場合の 1 経路しか実行していません。
そのため、カバレッジは `50%` となります。

ブランチカバレッジを用いれば、プロダクションコードの内容によって計測数値が影響を受けることはなくなります。

### カバレッジはテストの質を評価できない

よく、「カバレッジが高いほど良いテストである」と思われていますが、そんなことはありません。
カバレッジは**テストの質が悪いことを示せても、良いことは示せない**からです。

先程のコードカバレッジが良い例です。
プロダクションコードの書き方によって 83% → 100%に向上しましたが、検証している内容は変わっていないので、テストの質も変わりません。

では、ブランチカバレッジはどうでしょうか？
コードカバレッジよりも正確な計測結果を出せていましたね。
しかし、どちらの計測を行なってもテストの質を評価することはできません。

なぜ、カバレッジではテストの質を評価できないのでしょうか？
理由は次の 2 つです。

#### 1. プロダクションコードが検証されたのかを保証できない

カバレッジは「プロダクションコードがテストで実行された」ことを教えてくれます。
しかし、**「テストによってプロダクションコードが適切に検証された」ことは教えてくれません**。

「実行された」と「検証された」では意味合いがまったく異なります。
![](https://storage.googleapis.com/zenn-user-upload/1564a7584370-20241130.png)

カバレッジでは「検証された」ことを確認しないため、次のようなテストコードでも 100%となります。

```ts
test("should return false for short strings", () => {
  const result1 = isStringLong("abc"); // ←　trueを返すが、その結果は確認されない
  const result2 = isString("abcdef"); // ←　falseを返すが、その結果は確認されない
});
```

ただ関数を実行しただけで、戻り値の検証を一切していません。
しかし、コードカバレッジ・ブランチカバレッジはいずれも 100%となります。
このように、期待結果を検証していないテストを「**確認不在のテスト**」と言ったりします。

:::message

**検証するためには、「何を確認するのか？」をテストコード上で明確に定義する必要がある。**

:::

#### 2. ライブラリ内のコードは計測の対象外となる

カバレッジのもう一つの限界として、**外部ライブラリや依存するモジュールのコード**は計測の対象外であるという点があります。

例えば、プロジェクトで外部のデータフォーマット変換ライブラリ（JSON をオブジェクトに変換する）を使っているとしましょう。

```ts
import * as parseJson from "some-json-library";

export function parseUserData(jsonString: string): User {
  return parseJson(jsonString);
}

test("parseUserData should be called with JSON string", () => {
  // カバレッジを増やすためだけのテスト
  parseUserData('{"name": "John", "age": 30}');
});
```

この場合、カバレッジが 100%となります。
しかし、このテストは本当の意味でプロダクションコードを網羅しているわけではありません。
なぜなら、テストコードでは `parseJson` の中身をカバレッジの計測対象から外しているからです。

ただ、「`parseJson` の中身まで考慮して `parseUserData` をテストすべき」というのは誤りです。
`parseJson` の中身をテストするのは `parseUserData` の単体テストの責務外です。

:::message

**カバレッジからはテストが十分に行われているということを確認できない。**

**カバレッジとは「どのコードに対するテストが不足しているか？」を確認できる指標である。**

:::

### カバレッジ向上を目標にするのはアンチパターン

カバレッジからはテストの質を評価することができません。
しかし、「どのコードに対するテストが不足しているか？」を確認することは可能です。
そのため、カバレッジの計測により、未テストのリスクが高い部分に対して適切なテストを補うことができます。
なのでカバレッジの計測を行うこと自体は意義があるものです。

しかし、カバレッジの数値を良くすることを目標とするのはアンチパターンであり、プラクティスとして取り入れるべきではありません。

カバレッジの向上を求めると、**開発者は数値目標を達成することに集中しがちです**。
そうなると、質の低いテストが多くなってしまいます。
例えば、関数を呼び出すだけの「確認不在のテスト」を書いて、カバレッジを 100%にしてしまうケースです。

質の低いテストが多くなると、どうなりますか？
そう、ソフトウェアに「無秩序」を生み出してしまいます。
テストの目的は「ソフトウェアの成長を持続可能なものにするため」即ち「無秩序から脱却するため」です。
カバレッジを気にして質の低いテストを量産してしまっては元も子もありません。

:::message
**カバレッジの計測を最大限に活かすために**

数値を目標とせず、「どのコードに対するテストが不足しているか？」を確認するためのものとして捉えましょう。
:::

## 何がテストの質を良くするのか？

テストの質を適切に評価する方法は何か？
各テストケースを 1 つずつ評価するしかない。
ただ、すべてのテストケースを 1 度に評価する必要はない。
評価は段階的に実施する。

「テストの質が高い」ことを自動で評価する方法は存在しない
質の評価は個人的な判断に基づいて行われる。

テストの質を良くする要素は以下の 3 つ。

1. 開発サイクルの中でテストできる
2. コードベースの重要な部分のみがテスト対象となっている
3. 最小限の保守コストで最大限の価値が生み出せている

### ① 開発サイクルの中でテストできる

開発中でも常にテストを実施できなければ自動化の意味はない。
コードに変更を加える度にテストを実行できるようにするのが理想。

### ② コードベースの重要な部分のみがテスト対象となっている

プロダクションコードのすべてが単体テストをする価値があるわけではない。
単体テストにかける労力をソフトウェアにとって重要な箇所に向けることが重要。
重要でない部分は簡易的に・間接的に行う。

重要な部分とは？
→ ビジネスロジックを含む部分 → **ドメインモデル**
ビジネスロジックに対するテストは費用対効果が高い。

ビジネスロジックを含まないコードとは？

- インフラに関するコード
- 外部サービスや依存関係にあるもの
  - データベース
  - サードパーティのシステム
- 構成要素同士を結びつけるコード

もちろん、上記に対するテストに意味がないわけではない。

ドメインモデルを中心にテストするために意識すべき重要なことは？
→ **プロダクションコードにて、ドメインモデルとそうでない部分を切り離す**
これにより、単体テストをしやすくする。

### ③ 最小限の保守コストで最大限の価値が生み出せている

①、② だけではテストの質を十分に高めることはできない。

自動テストは保守が必要であり、コストがかかるもの。
よって、以下の基準を満たすテストケースのみを選択するべき。
**「テストすることで得られる価値が、そのテストを保守するコストを上回ること」**

どうすれば、基準を満たすテストケースを適切に選択できるようになるのか？

1. **価値のあるテストケースを認識できるようにする（価値の低いテストケースを認識できる）**
   どうすれば認識できるのか？
   → 価値を評価するための基準となる枠組みを知る

2. **価値のあるテストケースを作成できるようにする**
   どうすれば作成できるのか？
   → 設計のテクニックについて理解する
   プロダクションコードの設計がよくないと、価値あるテストが作れない。
