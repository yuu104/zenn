---
title: "単体テストの定義"
---

## 単体テストとは？

単体テストとは以下の 4 つを備えたテストのことです。

- 「単体（unit）」と呼ばれる少量のコードを検証する
- 自動化されている
- 実行時間が短い
- 隔離された状態で実行される

「隔離された状態で実行される」とはどういうことでしょうか？
↓↓↓
テスト対象（クラスや関数）が、**依存コンポーネントの影響を受けずにテストされる**ことを意味しています。
「隔離」の対象は「依存コンポーネント」です。

:::details 「コンポーネント」とは？
ここでいう「コンポーネント」とは、ソフトウェアの構成要素を指しており、具体的には以下のようなものが含まれます。

- クラスや関数
- モジュール
- 外部ライブラリやフレームワーク
- API やデータベース

:::

## 「依存」と「隔離」

単体テストにおいて、「依存をどう捉え、どのように隔離するか？」は非常に重要です。

### 依存とは？

ソフトウェア開発において、ほとんどのコードは他のコンポーネントに依存して動作しています。
![](https://storage.googleapis.com/zenn-user-upload/47ae479d2419-20241205.png =400x)
そのため、テスト対象のコードが他のコンポーネントに依存している場合、その依存関係が正しく動作しないとテスト結果に影響を及ぼすことがあります。

### 依存の種類

一口に「依存」と言っても、様々な観点があり、それぞれテストにおける扱い方が異なります。

1. **共有依存**
   **テストケース間**で共有される依存です。
   グローバルな設定ファイル、共有キャッシュ、静的なシングルトンオブジェクトなどが該当します。
   \
   もし共有依存を持つ複数のテストケースが同時に実行されると、**テスト間で副作用が発生しやすいです**。
   例えば、複数のテストが同じキャッシュにアクセスしたり、設定ファイルを書き換えたりする場合、一つのテストが他のテストに影響を及ぼしてしまいます。
   \
   よって、テスト対象に共有依存が存在すると、**検証結果が不安定になります**。

2. **プライベート依存**
   **テストケース間**で共有されない依存です。
   各テストケースが独立したコンポーネントを使用します。
   プライベート依存には、さらに次の 2 種類に分類できます。

   :::details ① 可変依存
   状態を変更可能な依存コンポーネントを指します。
   オブジェクトの内部状態が操作や外部からの影響によって変わる場合、この依存は可変とみなされます。

   以下の `UserSession` クラスは可変性があるオブジェクトです。

   ```java
   public class UserSession {
    private String userId;
    private boolean loggedIn;

    public UserSession(String userId) {
        this.userId = userId;
        this.loggedIn = false; // 初期状態ではログインしていない
    }

    // ユーザーIDを取得
    public String getUserId() {
        return userId;
    }

    // ログイン状態を取得
    public boolean isLoggedIn() {
        return loggedIn;
    }

    // ログイン状態を変更
    public void logIn() {
        this.loggedIn = true;
    }

    // ログアウト状態に変更
    public void logOut() {
        this.loggedIn = false;
    }
   }
   ```

   `loggedIn` フィールドは `logIn()` 及び `logout()` メソッドによって変更可能です。
   \
   そのため、テスト対象コンポーネントが `UserSession` に依存している場合、内部状態によって振る舞いが変化し、検証結果に影響します。

   :::

   :::details ② 不変依存
   初期化後、状態が一切変化しない依存コンポーネントです。

   ```java
   import java.util.Collections;
   import java.util.Map;

   public class StaticConfig {
   private final Map<String, String> settings;

       public StaticConfig() {
           settings = Map.of(
               "mode", "test",
               "version", "1.0.0"
           );
       }

       public String get(String key) {
           return settings.get(key);
       }

   }
   ```

   一度インスタン化したら、その振る舞いを変えることはできません。
   `settings` フィールドの値も不変であり、外部から変更できません。
   \
   そのため、テスト対象コンポーネントが `StaticConfig` に依存していても、内部状態に左右されることなくテスト結果が一貫します。

   :::

3. **プロセス外依存**
   テスト対象とは別のプロセスで動作する外部コンポーネントへの依存です。
   DB、外部 API、メッセージキューなどが該当します。
   \
   プロセス外依存は通常、ネットワークや外部プロセスを介して通信するため、テストの際にネットワークの遅延や外部システムの状態に依存することがあります。
   そのため、**テストの実行速度が遅くなる**可能性があります。

:::message
**プロセス外依存は共有依存？プライベート依存？**
ケースバイケースです。

DB はプロセス外依存であり、共有依存でもあります。
しかし、「各テストケースが同じ DB に依存している」というケースであればの話です。

もし、各テストケースを異なる Docker コンテナ上で実行させ、各コンテナ内に DB を用意したらどうなるでしょうか？
依存先が DB なので「プロセス外依存」であることには変わりません。
ただ、各テストケースは別の DB を使用しているため、「共有依存」ではなく「プライベート依存」です。

同様に、「読み込み専用の DB」も共有依存にはなりません。
なぜなら、読み込み専用であるため、あるテストケースが他のテストケースに影響していないからです。
:::

### 隔離とは？

依存の種類とテスト対象に与える影響についてお話しました。
単体テストでは、これらの依存をテスト対象から隔離することが重要になります。
それが、質の高いテストを作ることに繋がるからです。

「テスト対象から隔離する」とは具体的に何をするのでしょうか？
↓↓↓
依存コンポーネントを**テストダブル**に置き換えます。

テストダブルとは、**依存コンポーネントの代わりを務めるコンポーネント**のことです。
名前の通り、テスト時に「影武者」のような役割を果たします。
テストダブルにより、依存コンポーネントがテストに与える影響を排除し、テスト対象コードそのものの振る舞いを純粋に確認できるようになるのです。
![](https://storage.googleapis.com/zenn-user-upload/c376663c9591-20241208.png)

\
テストダブルにはいくつかの種類が存在し、用途によって適切なものを選択します。

:::details ① スタブ（Stub）
**依存先が返すデータを固定値にする**ためのテストダブルです。
テスト対象が期待するデータを簡単に準備できます。

\
**使用ケース :**
依存先の複雑なロジックを避けて、シンプルなデータを返したいとき。

\
**例 :**

```ts
const stubUserRepository = {
  find: (id: string) => ({ id, name: "Test User" }),
};

const result = stubUserRepository.find("123");
expect(result).toEqual({ id: "123", name: "Test User" });
```

- `stubUserRepository.find` は、常に `{ id: "123", name: "Test User" }` を返すようにスタブ化されています
- 実際のデータベースを使わずに、固定値を返すスタブを利用することで、外部依存を排除しています

:::

:::details ② モック（Mock）
**テスト対象が依存先をどう使ったか**を検証するためのテストダブルです。
「依存先のメソッドが呼び出されたか」「どんなデータを引数に渡したか」等を確認できます。
\
**使用ケース :**
テストケースが依存コンポーネントを「正しいデータで呼び出したか」を確認したいとき

\
**例 :**

```ts
const mockApiClient = {
  get: jest.fn().mockResolvedValue({ data: { name: "Alice" } }),
};

const userService = new UserService(mockApiClient);
await userService.fetchUser("123");

// API が正しい URL で呼び出されたかを確認
expect(mockApiClient.get).toHaveBeenCalledWith("/users/123");
```

- `jest.fn()`： Jest のモック関数を作成します。この関数は呼び出し履歴を記録し、検証可能です。
- `mockResolvedValue`： モック関数が Promise を返す場合、その返り値を指定します。この例では、`mockApiClient.get` を呼び出すと、常に `{ data: { name: "Alice" } }` が返ります。
- `toHaveBeenCalledWith`： モック関数が指定の引数で呼び出されたかを確認します。ここでは、`/users/123` という URL が正しく渡されたことをテストしています。

:::

:::details ③ スパイ（Spy）
**依存先のメソッドをそのまま使用しつつ、呼び出し履歴を記録する**テストダブルです。
モックのように完全に置き換えるのではなく、実際の処理を行いながら、その呼び出し状況を監視できます。

\
**使用ケース :**
実際の依存先の動作を維持しつつ、「正しい引数で呼び出されたか」や「呼び出し回数」を確認したいとき。

\
**例 :**

```ts
const spyLogger = jest.spyOn(console, "log");

console.log("Test message");

// console.log が呼び出されたか確認
expect(spyLogger).toHaveBeenCalledWith("Test message");
```

- `jest.spyOn`： 対象オブジェクトのメソッドをスパイ化します。この例では、`console.log` の呼び出し履歴を記録しています。
- スパイ化された console.log は、通常通りメッセージを出力しますが、どのような引数で呼び出されたかを確認できます

:::

:::details ④ フェイク（Fake）
**依存コンポーネントを簡易的に実装したもの**です。
実際の依存先と似た動きをしますが、軽量化されています。
\
**使用ケース :**
依存コンポーネントが本物だと準備が大変で、簡単な代替を用意したいとき。

\
**例 :**

```ts
const inMemoryDb: any[] = [];
const fakeDb = {
  insert: (item: any) => inMemoryDb.push(item),
  find: (predicate: (item: any) => boolean) => inMemoryDb.find(predicate),
};

fakeDb.insert({ id: "1", name: "Laptop" });
const result = fakeDb.find((item) => item.id === "1");
expect(result).toEqual({ id: "1", name: "Laptop" });
```

- `fakeDb` は実際のデータベースの代わりに、配列を使った簡易的なデータ管理を行っています
- データベースのセットアップやクリーンアップが不要なため、テストが軽量で高速になります

:::

:::details ⑤ ダミー（Dummy）
**とりあえず必要だから用意するだけ**のテストダブルです。
テストには使われないこともあります。
\
 **使用ケース :**
テスト対象が依存を必要とするが、その依存自体はテストで重要ではない場合。

\
**例 :**

```ts
const dummyDependency = {}; // 空オブジェクトを渡すだけ
const service = new SomeService(dummyDependency);

expect(service.doSomething()).toBe(true);
```

- `dummyDependency` は、`SomeService` のコンストラクタに渡すためだけのダミーオブジェクトです
- 実際にはテストには影響を与えないため、シンプルに空オブジェクトを使っています

:::
以上のように、単体テストでは目的に応じたテストダブルを用いて依存コンポーネントを隔離するのです。

### どの依存を隔離するのか？

「テストダブル」によって依存コンポーネントを隔離することをお話しました。
単体テストの構成要素である「**隔離された状態で実行される**」の意味が何となくわかってきたのではないでしょうか？

しかし、ここで次のような疑問が浮かぶかもしれません。

- 「すべての依存を隔離するべきなのか？」
- 「どの依存を隔離し、どの依存をそのまま使うべきなのか？」

実際、この疑問に対する明確な正解はありません。
どの依存を隔離するかは、プロジェクトの特性やテストの目的によって異なります。
そして、この考え方はエンジニアやチームによっても違いがあります。

この「どの依存を隔離するか」というテーマに対して、2 つの代表的なアプローチが存在します。
それが「**ロンドン学派**」と「**古典学派**」です。

## ロンドン学派

ロンドン学派は、**依存コンポーネントを徹底的に隔離する**という考えです。
ほぼすべての依存をテストダブルで置き換えます。

そのため、以下の恩恵を受けることが出来ます。

1. **テストが失敗したときに、どのコードが原因なのかを明確にできる**
   テスト対象への依存をすべてテストダブルに置き換えます。
   そのため、依存コンポーネントはテスト失敗の原因対象から外れ、テスト対象のコンポーネントに限定して問題箇所を特定できるようになります。
2. **複雑に絡み合った依存関係を分離できる**
   テスト対象のコンポーネントには大抵、複数の他のコンポーネントへの依存があります。
   その依存先コンポーネントもまた、依存しているコンポーネントが存在し...と、複雑になっています。
   このような複雑に絡み合ったコードをそのままテストに使用すると、以下の点でデメリットが生じます。

   - テストの実行に時間がかかる
   - テスト結果が不安定になる
   - テストが失敗した際の原因特定が困難になる

   すべてをテストダブルに置き換えれば、複雑な依存関係を打ち切ることができます。

3. **テスト対象コードの意図が明確になる**
   依存コンポーネントをすべて排除することで、1 テストケース : 1 コンポーネント とすることが出来ます。
   そのため、責務分離によってテストケースの作成がしやすくなり、テスト全体もシンプルな構造となります。
   ![](https://storage.googleapis.com/zenn-user-upload/a49a2b10181c-20241204.png =500x)
   _テストクラスとプロダクションコードのクラスを 1:1 にする_

:::message
**例外としての不変依存**
ロンドン学派では、原則すべての依存を隔離しますが、「不変依存」は例外とされ、そのまま使用します。

**理由:**

1. **テスト結果に影響しない**
   不変依存は状態が変わらず、テスト結果に影響を与えないため、そのまま使用しても特に問題がありません。
2. **モック化のコストが不変**
   不変依存をモック化することで逆に複雑さが増すかもしれません。
   その結果、テストの保守性が低下する可能性があります。

:::

## 古典学派

古典学派は、**共有依存のみを隔離する**という考えです。
他の依存コンポーネントは隔離せず、そのまま使用してテストします。

- なぜ共有依存だけ？
-
